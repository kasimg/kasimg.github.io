{"meta":{"title":"Kasim","subtitle":"Kasim","description":"","author":"Kasim","url":"kasimg.github.io","root":"/"},"pages":[{"title":"EM算法","date":"2020-03-05T01:17:45.000Z","updated":"2020-03-05T09:32:08.773Z","comments":true,"path":"to_be_posted/EM算法.html","permalink":"kasimg.github.io/to_be_posted/EM%E7%AE%97%E6%B3%95.html","excerpt":"","text":""},{"title":"","date":"2020-05-21T08:13:20.150Z","updated":"2020-05-21T08:13:20.150Z","comments":true,"path":"to_be_posted/IOC 理解.html","permalink":"kasimg.github.io/to_be_posted/IOC%20%E7%90%86%E8%A7%A3.html","excerpt":"","text":"IOC 理解曾经有一个学生叫小明，小明体弱多病，每天需要吃很多的药，而且这些药要按照顺序吃且必须吃完，否则会无效。 小明上学的时候把所有的药都放在身上，填满了所有口袋，这样就导致体育课的时候口袋里的药会不小心洒出来，而如果不小心丢失了一部分药的话，那么小明今天就相当于没有吃药。 小明有一个同学叫小强，小强和小明的情况差不多，不过小强不把药放在身上，而是交给老师保管，每当需要吃药的时候，小强就向老师索要。这样一来，小强就可以轻装上阵去上体育课，不用担心药会丢失。 这里的小强就运用了IOC思想，"},{"title":"","date":"2020-06-30T02:58:49.501Z","updated":"2020-06-30T02:52:45.519Z","comments":true,"path":"to_be_posted/IOC2.html","permalink":"kasimg.github.io/to_be_posted/IOC2.html","excerpt":"","text":"怎样才能算稳定的代码，什么是代码的稳定性 interface增强稳定性，同一方法的调用 工厂模式（其他创建性设计模式）将不稳定的代码转移到一个地方 不稳定性一定存在，转移不稳定代码的意义在于，将不稳定性控制在固定的地方，而其他地方的代码都稳定 变化造成不稳定，选什么英雄由用户决定，用户的选择充满了变化。new导致不稳定只是表象，实质是变化 开闭原则。变化的都是==控制代码== 举例，不稳定的代码是什么样的。需求变更之后，对原代码的改动大。有new的地方，万一创建方式变了或者类名改了，那么就不稳定。新增需求会有新的类出现，有新的类出现就有新的new出现，从而会导致代码改动，最终导致代码不稳定 interface改善 interface解决了方法的调用问题，而面向对象的程序中，就是不断地创建对象 + 调用对象的方法，所以方法调用统一之后，剩下的不稳定性就落在了new身上 工厂模式改善 探讨不稳定性的意义，根本原因 用户的传入的字符串，和实体类之间的转换问题 spring原理也是工厂模式 + 反射 缺点：反射性能不高，每次选择英雄时都要反射一次的话，性能消耗大。spring中使用缓存 目前为止，已经实现了开闭原则，不过还没有运用ioc原理，仅仅是获得了比较稳定的代码 配置文件的改动类似于用户输入的改动。所以把不稳定的内容放到配置文件当中，相当于解决了不稳定 消除factory，将对象作为参数直接传入 工厂模式是我们向工厂索取某个类，IOC是容器把对象直接给我们。 1class A &#123;2 private IC ic; // 依赖的对象需要是一个接口类型，运用多态存放3&#125; IC绑定一个类，绑定的类就写在配置文件当中，随时更改。容器用来装配。类比齿轮图。 到此为止，其实是实现了DI。那么何为IOC？主控方从A变成了容器，控制反转 所有的变化都是==控制代码==（流程、如何使用类），而不是新增的业务代码。 在控制代码很稳定的情况下，控制权就可以交到用户（产品经理等）手中。类比积木生产厂家，如果不用控制翻转，那么就是把拼装好的积木直接卖出去；使用IOC的话，程序员只需要生产一个个积木，把积木块卖出去，至于怎么拼，由用户决定"},{"title":"","date":"2020-05-27T09:29:53.776Z","updated":"2020-05-27T09:29:53.776Z","comments":true,"path":"to_be_posted/java学习心得.html","permalink":"kasimg.github.io/to_be_posted/java%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97.html","excerpt":"","text":"字符串比较 1String a = \"hello\";2String b = \"hello\";3// a == b true idea反编译 声明数组(对象)时，入栈，初始化后入堆。地址存放在栈中，值存放在堆中 二位数组在内存中如何存储？ 面向对象的本质：以类的方式组织代码，以对象的组织(封装)数据 String类型传参时也是值传递 new关键字本质是调用构造器 子类创建实例的时候，先调用父类的构造（隐式调用父类无参构造函数），向this上添加权限合适的属性与方法，之后调用子类自己的构造函数，向this上添加属性与方法，此时同名同参数的方法会替换之前的方法（自己的猜测，不一定正确） 定义的a和c只是在栈区域开辟了存放引用的空间，而c创建的时候没有new，也就是没有在堆区域中开辟空间。堆区域中的空间占用大于栈区域，所以这样就节省了空间 关于变量 关于变量： 上课的时候记笔记，记到了第N页。 你发现当前老师讲的知识点，之前就记过，于是你向前翻笔记本，终于在第X页第Y行找到了这个知识点。 于是你回到刚才的页码，记下”此知识点在第X页出现过”，你并不需要再将这个知识点记录一遍。 以后当你翻到第N页时，想回顾这个知识点，只需要翻到前面即可。 这样一来，就大大节省了笔记本的空间，而且避免了许多重复的操作。 这里的“此知识点在第X页出现过”就可以视为一个变量。 那么变量的“变”体现在哪里呢？考虑这样一个场景： 老师在复习上面的知识点时，觉得之前讲的并不完善，所以想增加一些内容，如果你没有使用变量，那么你就需要修改笔记本里所有关于这个知识点的内容；而如果使用了变量，那么只需要修改第X页的内容即可。 这里的变量”存放的值“就变了，但是它的名字“此知识点在第X页出现过”却没有变，意味着之前的名字仍然有效，完全不需要改动。 关于引用型变量： 上课的时候记笔记，你可以直接把笔记记在你自己的笔记本上。 或者你想偷懒，看到同桌已经把笔记全都记了下来，而你至于要看一下他把笔记记在了哪些页上，然后在你的笔记本上记下：”今日笔记详见同桌的笔记本的第X页-第Y页”。 后面你查看笔记的时候，前者只需要打开自己的笔记本就能看到；而后者需要先打开自己的笔记本，根据笔记本上的记录找到同桌的笔记本翻到对应的页码，才能看到课堂笔记。 后者就叫引用。 前者的优点是查阅方便，缺点是每个人都要抄一份笔记。 后者的优点是一份笔记可以供多人使用，节省了资源，缺点是查询时较为麻烦。 关于顺序作用域： 牛顿发现了重力，所以现在我们可以直接使用这个概念，而不需要再证明一次。 牛顿之前的人却不行。 整个世界就是一个作用域，后来者可以直接使用前人留下的知识。"},{"title":"","date":"2020-04-09T05:46:26.386Z","updated":"2020-04-09T05:46:26.386Z","comments":true,"path":"to_be_posted/Untitled.html","permalink":"kasimg.github.io/to_be_posted/Untitled.html","excerpt":"","text":"无法使用 JSX，除非提供了 “—jsx” 标志 解决方式："},{"title":"Hello World","date":"2020-03-19T05:04:33.275Z","updated":"2019-12-02T06:05:53.042Z","comments":true,"path":"to_be_posted/hello-world.html","permalink":"kasimg.github.io/to_be_posted/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"","date":"2020-05-18T09:15:24.593Z","updated":"2020-05-18T09:15:24.593Z","comments":true,"path":"to_be_posted/lambda.html","permalink":"kasimg.github.io/to_be_posted/lambda.html","excerpt":"","text":"lambda1. 基本用法定义接口 1interface A &#123;2 void say();3&#125; 用接口类型定义变量，多态 1A a = () -&gt; &#123;System.out.println(\"a\")&#125;; 相当于实现了A接口中唯一的方法say 因为只有一个接口，所以不用考虑到底实现了哪个方法，一定是实现了那个唯一的方法 最后返回一个A类型的实例 调用 1a.say(); 另外，如果要实现的方法有参数，那么也是类似： 1interface B &#123;2 void say(String words)&#123;&#125;;3&#125; 1B b = (String words) -&gt; &#123;System.out.println(words);&#125; 我们也可以不显式地指定被lambda表达式实现的接口的类型，比如： 1new Thread(() -&gt; &#123;2 //...3&#125;) 这里的lambda表达式就没有指定实现的接口的类型，不过Thread构造器中传入的是Runnable类型的对象，所以这里的表达式被识别为要实现Runnable接口 2. 再次简化如此一来，lambda表达式已经十分简洁，不过，还可以更进一步，再次简化。 2.1 简化1去掉参数类型。 1// 简化12B b = (words) -&gt; &#123;System.out.println(words);&#125;; 上述简化中，去掉了参数类型，那么如何保证传入的参数和定义时规定的参数是相同类型呢？这里就体现出了静态语言的好处，如果定义时的类型和调用时的类型不一样，那么编译器就会报错： 1b.say(123); // 报错 2.2 简化2去掉参数外边的小括号。 1// 简化22B b = words -&gt; &#123;System.out.println(words);&#125;; 不过这里需要注意的是，只有参数数量只有一个的时候才能这样使用，如果参数超过1个，那么必须加上括号 2.3 简化3去掉函数体的花括号。 1// 简化32B b = words -&gt; System.out.println(words); 这里需要注意的是，只有当函数体只有一行的时候才能去掉花括号，否则必须加上花括号。 另外，如果不加参数类型，那么所有参数都必须不加类型。 1interface B &#123;2 void say(String words, int count)3&#125;45// 报错6B b = (words, int count) -&gt; System.out.println(words + count);78// 报错9B b = (String words, count) -&gt; System.out.println(words + count); 要么都不加，要么都加。 3. 和js中箭头函数的区别和JavaScript中的箭头函数长得很像，不过java中的lambda能生成一个实例对象，而js中只是一个函数"},{"title":"scala","date":"2020-03-04T08:48:53.000Z","updated":"2020-03-13T09:28:06.171Z","comments":true,"path":"to_be_posted/scala.html","permalink":"kasimg.github.io/to_be_posted/scala.html","excerpt":"","text":"若函数没有参数，则调用时可以不加括号，类似于计算属性和js中的get方法 若有返回值，则最后一行作为结果 默认参数类似es6和python 关键字参数类似python for循环中加入条件判断 for (i &lt;- Range(0, 10) if i % 2 ==0) { println(i)} class中直接放入代码段 不显示定义array list等中的类型，则可以多类型并存 “hello”(4)是”hello”.apply(4)的简写"},{"title":"","date":"2020-06-30T05:56:54.911Z","updated":"2020-06-19T09:34:06.180Z","comments":true,"path":"to_be_posted/springmvc.html","permalink":"kasimg.github.io/to_be_posted/springmvc.html","excerpt":"","text":"springmvc 找dispatcher，dispatcher绑定了spring配置文件 通过dispatcher找到配置文件 经过处理器映射器，映射到配置的controller上 controller处理数据，返回视图对象(ModelAndView)给视图解析器 视图解析器结合视图对象渲染页面"},{"title":"","date":"2020-05-18T09:15:24.594Z","updated":"2020-05-18T09:15:24.594Z","comments":true,"path":"to_be_posted/关于java中多态的理解.html","permalink":"kasimg.github.io/to_be_posted/%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3.html","excerpt":"","text":"关于java中多态的理解人在一生中，会扮演许多角色，子女、学生、员工、父母等等。每个角色都从属与这个人。 而人在不同的角色中会有不同的反应，那说话举例，作为子女，向父母说话的时候会带上一点爱戴；作为学生，和老师说话的时候必定会充满尊敬；作为员工，和老板说话大概率会毕恭毕敬；而作为父母，与子女交流的时候都会有点训诫的意思。 当人被赋予不同的角色的时候，即使是同一个行为，也会根据角色的不用产生差异。 接下来到java中，首先定义一个类Person 1class Person &#123;2 public void say() &#123;3 System.out.println(\"I am a person\")4 &#125;5&#125; 接下来定义4种角色，继承自Person 1class Child extends Person &#123;2 @override3 public void say() &#123;4 System.out.println(\"我爱戴的父亲和母亲, ...\")5 &#125;6&#125;78class Student extends Person &#123;9 @override10 public void say() &#123;11 System.out.println(\"尊敬的老师, ...\")12 &#125;13&#125;1415class Employee extends Person &#123;16 @override17 public void say() &#123;18 System.out.println(\"是是是，老板，我这就去...\")19 &#125;20&#125;2122class Parent extends Person &#123;23 @override24 public void say() &#123;25 System.out.println(\"你看看你, ...\")26 &#125;27&#125; 每种角色类中都重写了父类的say方法，这也是多态的必要条件。如果不重写方法的话，那就根本谈不上多态了，清一色地说的都是相同的话。 接下来就到了分配角色的时间。 1Person person = new Child()2person.say()3// 输出：我爱戴的父亲和母亲, ... 当person被带入Child这个角色的时候，那么就会用和父母说话应该有的语气来说话。 同样的： 1person = new Student()2person.say()3// 输出：尊敬的老师, ...4 5person = new Employee()6person.say()7// 输出：是是是，老板，我这就去...8 9person = new Parent()10person.say()11// 输出：你看看你, ... 每次主体对象person被赋予一个新角色，它的say方法就会展现出和这个角色息息相关的特性，这就是多态。 抽象一下，当父类类型的实例的引用指向子类时，如果这个子类重写了父类的某个方法，那么这个实例就会在这个方法上，表现出这个它自己的特性 同样，“人”这个父类也能很好地诠释多态，不同的风俗文化，导致世界各地的人的生活习惯截然不同。同样一个“人”，被细分到地球上某一块子区域后，行为就可能发生翻天覆地的变化，这就是多态。"},{"title":"test","date":"2019-12-02T08:08:41.000Z","updated":"2020-02-27T05:18:09.733Z","comments":true,"path":"to_be_posted/test.html","permalink":"kasimg.github.io/to_be_posted/test.html","excerpt":"","text":"正儿八经学技术 花里胡哨瞎折腾 七嘴八舌侃天地 多愁善感拾回忆"},{"title":"","date":"2020-06-30T05:57:01.539Z","updated":"2020-05-19T05:52:49.813Z","comments":true,"path":"to_be_posted/多线程.html","permalink":"kasimg.github.io/to_be_posted/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html","excerpt":"","text":"多线程 线程的状态1.实现方式与区别暂时两种 继承Thread；实现runnable 三个线程对应三个对象，各自使用自己对象的资源 三个线程对应一个对象，使用同一个对象的资源 2.礼让3.插队4.守护线程5.并发一间厕所很小，空间同时只能容纳一个人，但是它有两扇门M、N，每扇门都可以进出，而且门口都有指示牌指示了里面是否有人。 A、B都想上厕所，他们分别站在M和N门前，看到门牌上显示厕所里没有人。 A是运动员，手脚敏捷，很快打开门占用了厕所。B是个肥宅，慢了一步开了门，结果直接撞到了A。 B很费解，明明指示牌上写着里面没人，为啥有人呢？ list线程不安全 1for (int i = 0; i &lt; 100; i++) &#123;2 new Thread(() -&gt; list.add(i)).start();3&#125;4Thread.sleep(3000);5System.out.println(list.size());6// 输出可能小于100 这里的输出可能小于100，因为同一时间里，两个线程可能同时向内存中同一位置插入值，导致值的覆盖。所以list是线程不安全的。 Synchronized 同步关键字加在方法上 1public synchronized void run()&#123;&#125; synchronized块 1synchronized (this) &#123;&#125; 锁住会同时被多个线程操作（增删改）的对象，只能用在函数体里？ 6.锁死锁出了synchronized块才会释放资源 给线程加锁下面是模拟抢票的部分代码： 1private final ReentrantLock lock = new ReentrantLock(); //定义可重入锁2// ...3while (tickets &gt; 0) &#123;4 try &#123;5 lock.lock(); // 加上线程锁6 Thread.sleep(100); // 使得线程不安全的情况发生概率提升7 System.out.println(Thread.currentThread().getName() + \"获得了\" + tickets-- + \"张票\");8 &#125; catch (InterruptedException e) &#123;9 e.printStackTrace();10 &#125; finally &#123;11 lock.unlock(); // 无论如何要释放锁12 &#125;13&#125; 上述代码中，每次线程想操作ticket时，都需要申请锁，当锁已经锁住时，线程就无法向下走，看起来已经线程安全。 可是却出现了如下的输出： 1// 黄牛获得了1张票2// 我获得了0张票3// 你获得了-1张票 为什么明明加了锁，却还是出现了0和-1这种不应该出现的数字呢？ 加以分析，发现是这里出了问题： 1while (tickets &gt; 0) &#123;2 // ...3&#125; 这里的循环条件是ticket&gt;0，同一时间可能有多个线程通过了这个判断，因为判断之前并没有加锁，而是在操作ticket之前才加锁。 所以对于ticket&gt;0的判断应该放到锁之后： 1while (true) &#123;2 try &#123;3 lock.lock();4 Thread.sleep(100);5 if (tickets &gt; 0) &#123;6 System.out.println(Thread.currentThread().getName() + \"获得了\" + tickets-- + \"张票\");7 &#125; else &#123;8 break;9 &#125;10 &#125; catch (InterruptedException e) &#123;11 e.printStackTrace();12 &#125; finally &#123;13 lock.unlock();14 &#125;15&#125; 这样一来，之后获取到锁之后才能对ticket进行判断，同时最多只有一个线程进行判断，从而保证了线程的安全。 7.线程通信"},{"title":"","date":"2020-06-18T09:41:14.291Z","updated":"2020-06-18T09:41:14.291Z","comments":true,"path":"to_be_posted/微服务.html","permalink":"kasimg.github.io/to_be_posted/%E5%BE%AE%E6%9C%8D%E5%8A%A1.html","excerpt":"","text":"微服务 https://insights.thoughtworks.cn/microservices-martin-fowler/ 通信模式的改变 加大粒度"},{"title":"","date":"2020-06-30T05:57:16.054Z","updated":"2020-05-19T05:52:49.814Z","comments":true,"path":"to_be_posted/数据库.html","permalink":"kasimg.github.io/to_be_posted/%E6%95%B0%E6%8D%AE%E5%BA%93.html","excerpt":"","text":"delete之后，重启数据库，INNoDB自增项会置为1，MyISAM则不会，因为前者存在内存中，后者存在文件中 | 查询种类 | 查询规则 || ————— | —————————————————————————————— || inner join | 只要有匹配，就返回 || left join | A left join B，返回A的所有符合条件的行(即使B中没有)，如果B没有用null代替 || right join | 和上面相反 | ant design pro 规范性和性能的问题 关联查询的表不得超过3张 考虑商业化的需求和目标、成本和用户体验，数据库的性能更加重要 在性能要求得到满足的情况下，再去考虑规范性 故意增加一些冗余字段，以减少查询时关联的表的数量 增加一些计数列，每当增加或删除记录时维护这些列，使得查询记录数的时间复杂度变为O1 prepareStatement可以防止sql注入，通过在传参外层加上’’来防止。"},{"title":"","date":"2020-05-21T09:00:13.563Z","updated":"2020-05-21T09:00:13.563Z","comments":true,"path":"to_be_posted/注解.html","permalink":"kasimg.github.io/to_be_posted/%E6%B3%A8%E8%A7%A3.html","excerpt":"","text":"注解反射Class对象是对静态class文件内容的封装，当Class对象改变的时候，并不改变class文件，从而实现了动态性。 Class对象是每个类的结构模板 利用反射操作对象1Field name = c1.getDeclaredField();2name.set(user, \"kasim\"); // 这里的set类似于js中的apply方法 打通权限能够使反射（方法）执行效率 注解参数必须是常量"},{"title":"","date":"2020-06-30T02:52:45.521Z","updated":"2020-06-30T02:52:45.521Z","comments":true,"path":"to_be_posted/自动装配.html","permalink":"kasimg.github.io/to_be_posted/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.html","excerpt":"","text":"自动装配 应用启动的时候就进行实例化和注入 需要立即实例化的类下面依赖的类，即使打上@lazy也无法延迟。因为需要满足前者立即实例化的需求。懒加载的话，会在访问控制器的时候实例化对象。 自动装配不是装配业务类，而是装配第三方的jar包或者sdk 不仅仅是自动引入，而是把这些类==加入到IOC容器当中=="},{"title":"","date":"2020-06-19T09:34:06.191Z","updated":"2020-06-19T09:34:06.191Z","comments":true,"path":"to_be_posted/需要后期详细研究的点.html","permalink":"kasimg.github.io/to_be_posted/%E9%9C%80%E8%A6%81%E5%90%8E%E6%9C%9F%E8%AF%A6%E7%BB%86%E7%A0%94%E7%A9%B6%E7%9A%84%E7%82%B9.html","excerpt":"","text":"需要后期详细研究的点 进程和线程 包装类和基本类型 mysql引擎 innoDB底层原理 索引 索引优化 注解如何在编译器改变类中的内容？ 约定大于配置 负载均衡 消息队列 微服务架构 maven 约定大于配置的意义 序列化 深拷贝 原型模式中 序列化和反序列化 网络 IOC DI"},{"title":"","date":"2020-06-30T03:00:14.526Z","updated":"2020-06-30T03:00:14.526Z","comments":true,"path":"to_be_posted/IOC.html","permalink":"kasimg.github.io/to_be_posted/IOC.html","excerpt":"","text":"1. IOC 用户的需求导致源代码频繁更改 更改源代码是程序员的事情，所以此时主动权在程序员手里，而如果代码量巨大的话，更改操作代价极大。 用户只能提需求，而改变不了什么。 提供 set 方法和接口。 把不稳定的代码聚集到一起，只在一个地方改变代码 不稳定：需求发生改变时，代码需要大量变动 比如，一个导航系统，原来是刘亦菲的语音播报，可是有一天我突然想听林志玲的声音，如果控制权在程序员手里，那么我就需要向程序员提需求，让他改源代码，把语音更换为林志玲，然后重新发布程序，我再进行更新；而如果程序里提供了 set 方法，那么我就可以手动更改语音，甚至可以录自己的声音。程序不需要作任何改变。 1public void Navigator&#123;2 String voice = \"刘亦菲\";34 public void navigate() &#123;5 System.out.println(voice + \"为您导航\");6 &#125;7&#125;89// 如果是第一种情况，那么程序员需要把源代码改成：10public void Navigator&#123;11 String voice = \"林志玲\";1213 public void navigate() &#123;14 System.out.println(voice + \"为您导航\");15 &#125;16&#125;1718// 而如果提供接口的话，则是另一种情况：19public void Navigator&#123;20 String voice;2122 // 提供给用户的接口23 public void setVoice(String name) &#123;24 voice = name;25 &#125;26 public void navigate() &#123;27 System.out.println(voice + \"为您导航\");28 &#125;29&#125;30// 这样一来，用户就可以直接改变声音，控制权从程序员手中反转到了用户手中 可能这样感受不到太大的区别。那么想象一下，如果不仅仅是名字需要改，而且音色、音调、响度、语速、说话风格、背景音乐…等等非常多的参数需要更改时，会是一个什么样的场景？或者说，需要更改的不仅仅是一个值，由于牵扯太大导致整个对象都需要更改，那又会是什么样一个场景？ 所谓 IOC，一言以蔽之，所有对象交由 Spring 来创建、管理、装配！ 2. sping 中的 IOCspring 中使用配置文件代替了对象实例的创建，原来创建一个对象可能要像下面这样： 1public class Navigator &#123;2 private String voice;34 public void setVoice(String voice) &#123;5 this.voice = voice;6 &#125;78 @Override9 public String toString() &#123;10 return voice + \"竭诚为您播报\";11 &#125;12&#125;13// ...14Navigator nav = new Navigator(); 而在 spring 中，用 xml 配置文件代替了对象的实例化： 1&lt;bean id=\"nav\" class=\"com.kasim.pojo.Navigator\"&gt;2 &lt;property name=\"voice\" value=\"刘亦菲\"/&gt;3&lt;/bean&gt; 相应的，应该这样在代码中使用配置文件： 1// 获取spring上下文对象，或者叫spring容器。这个容器中存放了用户定义的对象的实例2// beans.xml是自定的xml文件，名称随意，不过标准名是applicationContext3ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");45// 从容器中获取需要的对象。做一个伸手党，需要什么，就像spring容器索取什么6// 这里获取了Navigator型的对象，getBean(\"nav\")中的nav和xml文件中的id对应7Navigator nav = (Navigator) context.getBean(\"nav\");89// 输出：刘亦菲竭诚为您播报10System.out.println(nav); 再回到 xml 文件中， 1&lt;property name=\"voice\" value=\"刘亦菲\"/&gt; 这一句表示在创建实例的时候给名字叫”voice”的变量赋值为”刘亦菲”。然而，这样使用是有条件的，看下面这段代码： 1public void setVoice(String voice) &#123;2 this.voice = voice;3&#125; 这里的 setVoice 方法很重要，第一，如果没有这个方法，那么 xml 中会找不到 voice 这个属性；第二，名字必须是驼峰式的 set + 变量名； 有了这个方法，spring 就知道如何给实例中的属性赋值了。所以就有了下面的操作： 1&lt;bean id=\"nav\" class=\"com.kasim.pojo.Navigator\"&gt;2 &lt;property name=\"voice\" value=\"林志玲\"/&gt;3&lt;/bean&gt; 直接把 value 改为”林志玲”，运行程序： 1// 输出：刘亦菲竭诚为您播报 简简单单修改配置文件，省去了许多写代码的时间。可能对于程序员来说多写几行代码不算什么，可是前面提过了，决定权需要掌握在用户手里，让用户能够高度自定义自己心仪的产品。虽然不能要求用户写代码，但是改改配置文件还是不在话下的，再不济，可以给一个可视化的界面，让用户间接地修改配置文件。 这样一来，spring 就通过配置文件实现了控制反转。 spring 如何创建对象？不难发现，上面的代码中我们没有用 new 关键字实例化任何一个自定义类，那么 spring 是如何实例化对象的？ 来测试一下： 1// 在Navigator类中显式定义无参构造2// 如果从spring容器中获取实例的过程中使用了new关键字，那么构造函数一定会被执行3public Navigator() &#123;4 System.out.println(\"无参构造函数被调用\");5&#125; 打上断点 debug： 1// 这句话执行完毕后，\"无参构造函数被调用\"就已经打印出来2ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); 所以得出结论，在获取 spring 容器的过程中，bean 就已经被实例化。 那么如果获取多次实例对象，会得到同一个实例吗？测试如下： 1// 获取两次nav实例2Navigator nav = (Navigator) context.getBean(\"nav\");3Navigator nav2 = (Navigator) context.getBean(\"nav\");45// 如果两次得到了同一个实例，那么这里一定会打印true6System.out.println(nav == nav2); 结果打印了 true，说明获取的是一个对象，那么问题来了，如果要获取多个对象该怎么办？ 默认使用无参构造 配置加载后，所有 bean 都初始化成了_一个_对象 需要多个实例怎么办？设置 scope 参数为 prototype 自动装配根据 set 方法后面的变量名寻找 id，大小写敏感，首字母必须小写 @Autowired 类加载之后，通过反射获取类的 class 对象，从 class 对象中获取@Autowired 注解信息，通过注解信息得到需要自动装配的对象的名称，也就是类中定义的名称；找名称之后，再去配置文件中寻找对应 id 的 bean，通过 bean 生成实例对象，最后注入类的实例。 @Autowired(required = false) 表示被注解的属性可以在 xml 中没有配置，也就是可以为空 null。使得配置文件更加灵活。 @Qualifier(value=”name”) 手动指定 xml 配置中对应的 id，防止有多个相同类但是 id 不同的 bean 在 java 中配置 spring 容器，作为 bean 的类必须加上@Component 注解，其中的属性也需要加上相应注解，不然无法成功注入。 无论在 xml 还是 java 中配置 spring 容器，@Component 注解都需要加上，表示这个类被 spring 托管了，至于怎么托管，是通过 xml 还是 java，由用户决定 java 或者 xml 本质上都是连接 spring 和 java 代码的桥梁 java 配置中，先通过@Bean 注解获取被托管的类的信息，如果这个类被托管了（加了@Component 注解），那么就注入，否则不会注入；自动注入也是类似。 用户总需要通过某种方式告诉 spring，这个类被托管了，可以是在 xml 中显式定义，也可以使用@Component 注解，使用@Component 后需要在 xml 中配置扫描的范围： 1&lt;context:component-scan base-package=\"com.kasim.pojp\"/&gt; 而在 java 中则需要用@Bean 标识出来。 3.代理模式3.1 静态代理 你要结婚了，有一大堆事情要做，请帖、喜糖、策划、预定饭店、预定车…如果全部由你来做的话，你一定会焦头烂额。当然你大可不必如此，只需要专注于如何盛装出席婚礼这件事，其他的事情全部交给婚庆公司去做，这样你就会轻松许多。 这里的婚庆公司就是代理，这种把不必要的事情委派给其他角色去做，自己只专注于核心业务的模式，就叫代理模式。 将公共操作提取出来放在代理对象中，独一无二的逻辑放在真实对象中实现 你和朋友正在打羽毛球比赛，每次打完一个球，你都需要跑到记分牌前更新比分信息，一局如果 20 个球，那么你就得跑 20 趟。 而如果你们找另外一个人专门更新比分信息，那么你们就省了许多事，只需要专心打球就行。 这里的第三个人就相当于代理，它完成了许多重复性的工作，让你们可以专注于核心的事情。 方便在原有的逻辑上增加一些公用的逻辑。而改动原有的业务代码，是大忌 拔河比赛如火如荼的进行着，因为顶着烈日，队员们缺水严重，急需补水。如果让队员们腾出一只手来喝水的话，非常可能就输掉了比赛。 而如果这时候找来一个另外的人，专门负责给队员们送水喝，那么队员们仍然可以专注于比赛，而且也解决了缺水的问题。 这个人就是代理，他相当于给所有的队员增加了一个喝水的功能，而队员不需要做任何的改变。 好处： 使真实角色的操作更加纯粹，减少耦合性 公共业务交给了代理角色，实现了业务分工 公共业务发生扩展的时候，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量翻倍 3.3 动态代理1// 首先写一个代理需要用到的接口2public interface Navigate &#123;3 void navigate();4&#125;56// 然后定义一个实现接口的类7public class Navigator implements Navigate &#123;8 @Override9 public void navigate() &#123;10 System.out.println(\"高圆圆竭诚为您播报\");11 &#125;12&#125; 因为动态代理时会产生一个代理对象，这个对象需要通过接口去访问原来类中定义的方法实现。 接下来按照官方文档，定义一个用来生成代理对象的类： 1public class MyProxy implements InvocationHandler &#123;23 // 被代理的对象4 private Object target;56 public void setTarget(Object target) &#123;7 this.target = target;8 &#125;910 // 动态获取代理类的方法11 public Object getProxy() &#123;12 return Proxy.newProxyInstance(this.getClass().getClassLoader(),13 target.getClass().getInterfaces(), this);14 &#125;1516 // 代理对象在调用被代理对象中的同名方法时，其实是调用了这个方法17 // 并通过反射的形式调用被代理对象中的同名方法18 @Override19 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;20 System.out.println(\"I am invoked\");21 Object result = method.invoke(target, args);22 return null;23 &#125;24&#125; 测试效果： 1// 创建被代理对象的实例2Navigate nav = new Navigator();34// 创建生成代理对象的对象实例5MyProxy myProxy = new MyProxy();67// 先设置要代理的对象8myProxy.setTarget(nav);910// 再生成代理类, 使用多态11Navigate proxy = (Navigate) myProxy.getProxy();1213// 这里会先打印\"I am invoked\" 再打印出 \"高圆圆竭诚为您播报\"14proxy.navigate(); 生成代理类的时候： 1return Proxy.newProxyInstance(this.getClass().getClassLoader(),2 target.getClass().getInterfaces(), this); 传入了 target.getClass().getInterfaces()参数，也就是被代理类的接口信息，代理类获取这个接口之后自己也实现了这个接口，所以代理类能够调用 navigate 方法。 传入了 this 参数，说明当前生成 proxy 类的类实例信息被代理类获取，其中的 invoke 自然也在其中。 1public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;2 System.out.println(\"I am invoked\");3 Object result = method.invoke(target, args);4 return null;5&#125; 这里传入了 method 参数，当代理类调用接口中的方法时，这个方法的信息就被获取并传入到 invoke 方法中，于是在 invoke 方法中就可以通过反射的方式来调用被代理对象实例中的方法。这里试验了一下调用方法时获取接口的方法对象： 1// 通过当前的调用栈信息获取当前调用的方法名2// [1]表示当前的执行堆栈3String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();45// 获取当前实例的接口对象，可能有多个6Class&lt;?&gt;[] interfaces = this.getClass().getInterfaces();78// 通过接口对象获以及方法名获取方法信息9// 这里因为只有一个接口所以直接用[0]访问，如果有多个的话可能需要遍历搜索10System.out.println(interfaces[0].getDeclaredMethod(methodName)); 上面的代码纯粹自己瞎琢磨，因为源码现在还看不懂… 在调用原本方法之余，invoke 方法中可以加上任何公用的方法，从而实现代理模式。 动态代理省去了代理类中对于接口方法的具体实现，而是通过传入的接口参数去实现 4. spring 中的 AOP多个点组成一个面 从静态代理到动态代理，省去了对于代理类的实现； 从动态代理到 spring 的 AOP，增加了一次可以代理的对象数量； 配置文件中可以批量代理多个类，一个表达式就搞定，省去了大量代码"},{"title":"","date":"2020-06-30T03:07:12.809Z","updated":"2020-06-30T02:52:45.520Z","comments":true,"path":"to_be_posted/理解IOC.html","permalink":"kasimg.github.io/to_be_posted/%E7%90%86%E8%A7%A3IOC.html","excerpt":"","text":"理解IOC1. 代码的稳定性1.1 开闭原则开闭原则（Open Close Principle, OCP）是指，软件对象应该对扩展开放，而对修改关闭。是软件工程领域一个非常重要的原则，它保证了代码的可扩展性和可维护性。 1.2 不稳定的代码在这里，姑且把“不符合开闭原则的代码”称为“不稳定的代码”，比如，以dota为例，下面的代码就是不稳定的： 首先定义三个个英雄类： 1// 定义一个Axe类，表示“斧王”这个英雄2// 英雄有4个主动技能3public class Axe &#123;4 public void skill1() &#123;5 System.out.println(\"Axe releases 'Berserker's Call'\");6 &#125;7 public void skill2() &#123;8 System.out.println(\"Axe releases 'Battle Hunger'\");9 &#125;10 public void skill3() &#123;11 System.out.println(\"Axe releases 'Counter Helix'\");12 &#125;13 public void skill4() &#123;14 System.out.println(\"Axe releases 'Culling Blade'\");15 &#125;16&#125;1718// 具体实现与上面类似，都是实现4个技能，这里不再赘述。19public class Kunkka &#123;&#125;20public class Zeus &#123;&#125; 假设用户通过在命令行输入的名字来选择英雄，那么逻辑如下： 1// 主函数2public static void main(String[] args) throws Exception &#123;3 System.out.println(\"Please enter a hero's name: \");4 Scanner scanner = new Scanner(System.in);5 String name = scanner.nextLine();6 7 switch (name) &#123;8 case \"Axe\": &#123;9 Axe axe = new Axe();10 axe.skill1();11 break;12 &#125;13 case \"Kukka\": &#123;14 Kunkka kunkka = new Kunkka();15 kunkka.skill1();16 break;17 &#125;18 case \"Zeus\": &#123;19 Zeus zeus = new Zeus();20 zeus.skill1();21 break;22 &#125;23 default: throw new Exception(); // 如果输入的不是定义的三个英雄的名字则抛出异常24 &#125;25&#125; 上面的逻辑，乍一看清晰明了，不过仔细揣摩之后有许多问题： 第一，英雄是会不断增加的，如果向上面这样写的话，每次增加英雄都需要改变主函数里的逻辑，现在只有一个“释放第一个技能”的逻辑，万一后面有非常多的逻辑的话，代码改动量非常大，可维护性极差。 第二，如果英雄类中的方法，或者类名发生了变化，那么这里也需要改动。 第三，不仅仅是这里用到了英雄类，其他地方也可能引用，那么一旦第一或者第二种情况发生，所有用到改动的英雄类的地方都需要改动，这是毁灭性的灾难。 基于以上三点，这段代码是不符合开闭原则的。 2. 第一次改进 — interface 在面向对象的程序中，就是不断地创建对象，然后调用对象的方法来完成逻辑。 那么，只要统一了对象的创建和方法的调用，那么代码就稳定了。 这里先解决方法的统一。 2.1用interface改进代码首先定义英雄接口： 1// 接口定义了四个方法，对应英雄的四个技能2public interface Hero &#123;3 void skill1();4 void skill2();5 void skill3();6 void skill4();7&#125; 接着让英雄类实现接口： 1// 具体实现未变，故省略2public class Axe implements Hero &#123;&#125;3public class Kunkka implements Hero &#123;&#125;4public class Zeus implements Hero &#123;&#125; 最后修改主函数： 1public static void main(String[] args) throws Exception &#123;2 System.out.println(\"Please enter a hero's name: \");3 Scanner scanner = new Scanner(System.in);4 String name = scanner.nextLine();5 Hero hero;6 switch (name) &#123;7 case \"Axe\": &#123;8 hero = new Axe();9 break;10 &#125;11 case \"Kukka\": &#123;12 hero = new Kunkka();13 break;14 &#125;15 case \"Zeus\": &#123;16 hero = new Zeus();17 break;18 &#125;19 default: throw new Exception();20 &#125;21 hero.skill1();22&#125; 可以看到，改动之后，不需要再在每个switch分支当中调用skill1方法，而是统一地在第21行调用了方法，这样一来就实现了方法调用的统一。 2.2 interface的意义2.2.1 优点使用interface主要有两个优势： 第一，精简代码。如果有100个英雄，那么这样改进就省下了将近100行代码；如果4个技能都需要调用，那么就剩下了近400行代码。 第二，面向接口编程。hero对象利用了多态，并不关注存放的具体是那个英雄，只要实现了Hero接口，那么接下来的方法调用就一定不会出错。 其中第二点当中蕴含的思想尤为重要。 2.2.2 缺点没有解决对象创建的统一。 3. 第二次改进 — 工厂模式 既然已经解决了方法统一的问题，那么就只剩下方法创建的统一了。 也就是说，把存在==new==关键字的地方统一起来，就解决了稳定性的问题。 3.1 用工厂模式改进代码首先定义英雄工厂类： 1public class HeroFactory &#123;2 // 静态方法获取英雄3 public static Hero getHero() throws Exception &#123;4 System.out.println(\"Please enter a hero's name: \");5 Scanner scanner = new Scanner(System.in);6 String name = scanner.nextLine();7 Hero hero;8 switch (name) &#123;9 case \"Axe\": &#123;10 hero = new Axe();11 break;12 &#125;13 case \"Kukka\": &#123;14 hero = new Kunkka();15 break;16 &#125;17 case \"Zeus\": &#123;18 hero = new Zeus();19 break;20 &#125;21 default: throw new Exception();22 &#125;23 return hero;24 &#125;25&#125; 可以看到，上面的代码其实就是把原来主函数当中的逻辑搬运到了HeroFactory类中，最终返回一个Hero对象。 接着改变主函数： 1public static void main(String[] args) throws Exception &#123;2 Hero hero = HeroFactory.getHero();3 hero.skill1();4&#125; 这样一来，主函数当中就消除了new关键字，可以认为初步稳定了。 3.2 工厂模式的意义3.2.1 初步稳定的局限上面提到了初步稳定，为什么是初步稳定？因为虽然没有使用new关键字实例化HeroFactory类，这里还是用到了具体的类。如果后期需要获取一个“地形对象”，那么还需要创建一个“地形工厂”，这就导致在主函数中需要增加使用地形工厂获取地形对象的语句。 这也就说明：主函数仍然会变动，不是真正的稳定。 3.2.2 超级工厂上面提到，由于工厂数量可能会增加，导致了不稳定性，那么如果有一个==超级工厂==，这个工厂里可以获取各种各样的对象，那么就不需要再增加其他工厂，也就不会导致不稳定性。 所以： 如果工厂大到可以获取任何对象，那么就能保证==主函数的稳定== 3.2.3 不稳定性的转移注意到，上面总结出来的结果是：保证主函数的稳定。只是保证了主函数部分的稳定。 其实也很好理解，因为new关键字仍然存在于工厂类中，并没有被消除。 那么这种“治标不治本”的稳定性有意义吗？ 答案是肯定的，试想一下，如果整个项目当中，有100个地方需要获取Hero对象，一旦对象创建方式发生变化，不用工厂模式的情况下，这100处就都需要修改，如果有1000，10000处使用呢（虽然夸张，但是能说明问题）？ 而使用了工厂模式的话，只有工厂类内部需要改动。 所以，工厂模式的意义就在于： 将所有不稳定性转移到同一个地方，来保证其他地方的稳定性。 4. 第三次改进 — 反射 工厂模式将所有的不稳定集中起来，保证了其他地方的稳定。 那么，只要消除了工厂中的不稳定性，就彻底消除了代码中的不稳定性。 3.1 用反射改进代码用反射形式改进工厂： 1public class HeroFactory &#123;2 // 如果输入的类名不合法，那么会b3 public static Hero getHero() throws Exception &#123;4 System.out.println(\"Please enter a hero's name: \");5 Scanner scanner = new Scanner(System.in);6 String name = scanner.nextLine();7 // 包全路径名的前缀8 String packagePath = \"com.IOC.hero.\";9 10 // 使用反射获取元类对象11 Class&lt;?&gt; HeroMeta = Class.forName(packagePath + name);1213 // 使用元类创建实例14 Hero hero = (Hero)HeroMeta.newInstance();1516 return hero;17 &#125;18&#125; 这里使用反射机制，直接通过用户传入的字符串获取了元类对象，通过元类对象创建了实例。 这样一来，工厂中的new也被消除了，这么一来，代码中的所有不稳定性就全部消除了（认为存在一个超级工厂）。 3.2 反射的优劣 优势：去除了new关键字，使得工厂中的代码真正稳定 劣势：性能较低，如果使用的地方很多，会导致系统整体效率下降。（==spring中使用缓存解决这个问题==） 3.3 重新理解不稳定性如果需要增加一个英雄，那么增加类在所难免，那么“增加类”这个操作是不是也可以认为是“不稳定”的呢？ 如果需要改变一个技能的施法动作，也就是要在skill1中改变具体的逻辑代码，这可以认为是“不稳定”吗？ 我的理解是，不能。 因为这些改动是==不可避免==的。各项数值的调整，都需要去改变具体的逻辑，这是一定的。 而前文在解决的不稳定性，都是==可以避免==的，可以通过不同的写法来避免。 根据改动是否可以避免，姑且把代码分为两类： ==业务代码==。变动不可避免的代码，具体体现为项目中具体的类的实现，随着需求改变不断改变。 ==控制代码==。变动可以避免的代码，具体体现为方法的创建、调用等，业务代码的变动不需要改动这部分代码。因为起着调度、流程控制的作用，所以叫控制代码。 基于上面的分类，其实前面的讨论，都是对于控制代码而言的。 所谓的不稳定性，只存在于==控制代码==当中，对于==业务代码==，因为一定是不稳定的，所以讨论稳定性没有意义。 5. 依赖注入 到目前为止，已经消除了不稳定性，让代码符合了开闭原则。 不过，还完全没有运用IOC原理 对于依赖注入(Dependency Injection, DI)，我个人的理解是：依赖注入是IOC思想的一种体现方式。 5.1 实现依赖注入5.1.1 原来的依赖形式下面来看看普通的依赖形式，首先定义皮肤接口和皮肤类： 1public interface Skin &#123;2 void showSkin();3&#125;45public class MySkin implements Skin &#123;6 @Override7 public void showSkin() &#123;8 System.out.println(\"show my skin\");9 &#125;10&#125; 下面在英雄类中加入皮肤类依赖： 1public class Axe implements Hero &#123;2 public void showSkin() &#123;3 Skin skin = new MySkin(); // 加入依赖4 skin.showSkin();5 &#125;6&#125; 这样一来就实现了Hero和Skin的依赖关系，Hero依赖Skin，Hero只有拥有了皮肤，才能正常显示在玩家面前(没有额外皮肤的话，默认是初始皮肤)。 可以发现，这里的主导权在Hero手中，Hero需要主动生成Skin，或者在构造时设置Skin。 而由于new的出现，代码中就有了不稳定性。 直接的、正向的依赖关系会导致代码的不稳定性。 5.1.2 依赖注入上面的依赖关系会导致代码的不稳定性，这里用工厂模式来消除不稳定性。 首先在Hero接口中增加方法： 1public interface Hero &#123;2 void skill1();3 void skill2();4 void skill3();5 void skill4();6 void setSkin(Skin skin); // 增加设置skin的方法7 void showSkin(); // 增加展示皮肤的方法8&#125; 这里采用属性注入的方式。 然后在Hero中添加set方法和showSkin方法： 1public class Axe implements Hero &#123;2 Skin skin;34 public void setSkin(Skin skin) &#123;5 this.skin = skin;6 &#125;7 // 省略无关代码...89 @Override10 public void showSkin() &#123;11 skin.showSkin();12 &#125;13&#125; 接下来修改工厂类： 1// 上面的逻辑省略...2Hero hero = (Hero)HeroMeta.newInstance();3hero.setSkin(new MySkin()); // 注入skin 最后看主函数： 1Hero hero = HeroFactory.getHero();2hero.showSkin(); 可以看到，主函数中并没有主动调用set方法设置Hero类的依赖，而是由工厂代为设置了。 Hero依赖的内容，不再由Hero主动去索取，而是由工厂类注入，换句话说，工厂变成了主动方而Hero变成了被动方。 这样一来，控制权就从Hero手中，转移到了工厂类手中。 也就实现了==控制反转(Inversion of Control, IOC)==。 这种实现方式被称为==依赖注入==。 5.2 第三次理解不稳定性不难发现，在工厂中向Hero注入Skin的时候，使用了new关键字，这又导致了代码的不稳定。 在考虑如何消除不稳定性之前，可能先要考虑下面这个问题： 这段代码属于==控制代码==，还是==业务代码==？ 结合实际场景，一个英雄可能有多个皮肤，而使用哪一个皮肤是用户要决定的事情，所以，皮肤的不断切换、不断变化是==不可避免==的。 因为不稳定性不可避免，所以这段代码属于业务代码，那么这里的不稳定性就可以不用考虑。 5.3 类与容器的关系容器，也就是所谓的超级工厂，将像是独立于类之外的存在，它负责给类们装配、注入各种各样的依赖，从而使得类与类之间能够协同工作。（可以参考网上常用的齿轮图） 6. IOC6.1 在DI层面上再次抽象在第5节中，确实实现了Hero和工厂类之间控制权的反转。 不过，如果站在更高一层来看，所有的代码逻辑都是程序员来写，主动权牢牢控制在程序员手中，那么能不能将程序员手上的控制权，转移到其他角色，例如用户、产品经理手中呢？ 答案是肯定的。 6.1.1 转移程序员的控制权首先看工厂类的实现： 1Hero hero = (Hero)HeroMeta.newInstance();2hero.setSkin(new MySkin()); // 注入skin 虽然这里的不稳定性不可避免，但是每次需要更换皮肤是，还是需要程序员来更改逻辑。 要是由其他角色来告诉工厂该注入哪一个皮肤的话，那么控制权就从程序员手上释放掉了。 但是不可能要求其他角色(产品、用户)也会写代码。 那么有没有一种方式，使得不会写代码的人，也能修改逻辑呢？ 是有的。 6.1.2 连接其他角色与代码实际情况中，用户是通过UI界面来选择皮肤的，而且控制权确实是在用户手中，因为不可能每次用户更换皮肤时，程序员都去更改相应的逻辑，然后再重新上线游戏。 所以这里的UI就是连接用户和代码的桥梁，使得用户也可以控制程序的走向。 再比如，原来系统中使用的是MySql数据库，现在需要改成SqlServer数据库，那么就可以把数据库的配置信息放到配置文件中，例如： 1database = 'MySql' 这样一来，程序员就只需要关注SqlServer数据库操作的具体实现，而产品经理就可以负责“注入数据库”，也就是更改配置文件，比如改成： 1database = 'SqlServer' 虽然不能要求产品会写代码，但是改个配置文件还是可以的。 而且如果后续要是再改回MySql的话，只需要更改配置文件，项目代码完全不需要改动。 这样的话，就实现了==角色之间的控制反转==。 6.2 对IOC的浅见马丁老爷子说过，IOC是个非常抽象，非常模糊的概念，为了让人更好理解，老爷子才拿出了依赖注入这个例子，所以对于IOC的理解需要在日后的工作中慢慢体会，徐徐图之。 最后用一个例子结束本文。 一个项目就像是一个积木工厂，程序员是工厂中的员工，负责制造积木。 把积木拼装好之后用胶水死死粘上再卖出去，是非IOC。 把积木造出来之后直接卖出去，是IOC"},{"title":"","date":"2020-06-23T06:20:26.572Z","updated":"2020-06-23T06:20:26.572Z","comments":true,"path":"to_be_posted/数据结构/哈希表.html","permalink":"kasimg.github.io/to_be_posted/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8.html","excerpt":"","text":"用数组代替哈希表，能代替尽量代替（key值可以转化为数字的时候） map.values() 是Collection类型，可以用于直接初始化List"},{"title":"","date":"2020-06-16T02:57:35.590Z","updated":"2020-06-16T02:57:35.590Z","comments":true,"path":"to_be_posted/数据结构/树.html","permalink":"kasimg.github.io/to_be_posted/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91.html","excerpt":"","text":"1. 二叉树遍历1.1 前序递归 1public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;2 List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;();3 if(root==null) return pre;4 pre.add(root.val);5 pre.addAll(preorderTraversal(root.left));6 pre.addAll(preorderTraversal(root.right));7 return pre;8&#125; 迭代 1public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;2 List&lt;Integer&gt; list = new ArrayList&lt;&gt;();3 if (root == null) return list;4 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();5 stack.push(root);67 while (!stack.isEmpty()) &#123;8 root = stack.pop();9 list.add(root.val);10 if (root.right != null) stack.push(root.right);11 if (root.left != null) stack.push(root.left);12 &#125;13 return list;14&#125; 1public List&lt;Integer&gt; preorderTraversal(TreeNode node) &#123;2 List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();3 Stack&lt;TreeNode&gt; rights = new Stack&lt;TreeNode&gt;();4 while(node != null) &#123;5 list.add(node.val);6 if (node.right != null) &#123;7 rights.push(node.right);8 &#125;9 node = node.left;10 // 如果没有左节点，且栈中还有元素，那么栈顶元素取出11 if (node == null &amp;&amp; !rights.isEmpty()) &#123;12 node = rights.pop();13 &#125;14 &#125;15 return list;16&#125; 1.2 中序1public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;2 List&lt;Integer&gt; list = new ArrayList&lt;&gt;();3 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();45 while (root != null || !stack.isEmpty()) &#123;6 while (root != null) &#123;7 stack.push(root);8 root = root.left;9 &#125;10 root = stack.pop();11 list.add(root.val);1213 root = root.right;14 &#125;15 return list;16&#125; 1.3 后续迭代 1// n叉树，类比二叉树2public List&lt;Integer&gt; postorder(Node root) &#123;3 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();4 if (root == null) return list;5 LinkedList&lt;Node&gt; stack = new LinkedList&lt;&gt;();6 stack.push(root);78 while (!stack.isEmpty()) &#123;9 root = stack.pop();10 list.add(root.val);11 for (Node p: root.children)12 if (p != null) stack.push(p);13 &#125;14 Collections.reverse(list);15 return list;16&#125; 1.4 层次1// n叉树2public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;3 List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();4 if (root == null) return list;5 LinkedList&lt;Node&gt; queue = new LinkedList&lt;&gt;(); 6 queue.add(root);7 while (!queue.isEmpty()) &#123;8 int size = queue.size();9 List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();10 for (int i = 0; i &lt; size; i++) &#123;11 Node node = queue.removeFirst();12 temp.add(node.val);13 // list中没有null14 for (Node p: node.children) queue.add(p);15 &#125;16 list.add(temp);17 &#125;18 return list;19&#125;"},{"title":"","date":"2020-06-23T09:40:40.109Z","updated":"2020-06-23T09:40:40.109Z","comments":true,"path":"to_be_posted/数据结构/字符串.html","permalink":"kasimg.github.io/to_be_posted/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2.html","excerpt":"","text":"charAt、toCharArray非常消耗时间，可以用substring(i, i + 1)代替，为什么？ char[] -&gt; string 1String.valueof(ca);"},{"title":"","date":"2020-06-30T05:56:20.283Z","updated":"2020-05-27T09:29:53.775Z","comments":true,"path":"to_be_posted/Mybatis.html","permalink":"kasimg.github.io/to_be_posted/Mybatis.html","excerpt":"","text":"Mybatis ​ 官方文档：https://mybatis.org/mybatis-3/zh/index.html INNODB 和MYISAM 引擎区别 工厂模式 用map代替实体类进行参数传递，不需要进行实体类的实例化操作(实例化时可能需要各种参数，但是实际使用时并不需要)，更加灵活 一个大箱子里存放了许多东西，假设你每次要拿的东西都在最下面。 那么你每次想获取物品的时候，都需要搬开上面所有的东西。 而如果你换成用多层抽屉存储，那么你想要什么，直接打开对应的抽屉即可。 用大箱子存就相当于把实体类当做参数传递，实体类每次初始化时可能都需要大量的参数。 用抽屉存放相当于将参数改为map类型，map中只需要存放需要的参数即可。 如果只有单个参数，那么XML中可以不写parameterType，否则需要加上@param注解 你面前有十个一模一样的密封的黑盒子，其中一定有一个盒子是空的，现在让你选出空盒子，你肯定不可能每次都找到正确的盒子。 而如果只有一个盒子，因为一定有一个盒子是空的，那么肯定是那个唯一的盒子是空的。 Properties 标签，引用配置文件 关于引用： 上课的时候记笔记，你可以直接把笔记记在你自己的笔记本上。 或者你想偷懒，看到同桌已经把笔记全都记了下来，而你至于要看一下他把笔记记在了哪些页上，然后在你的笔记本上记下：”今日笔记详见同桌的笔记本的第X页-第Y页”。 后面你查看笔记的时候，前者只需要打开自己的笔记本就能看到；而后者需要先打开自己的笔记本，根据笔记本上的记录找到同桌的笔记本翻到对应的页码，才能看到课堂笔记。 后者就叫引用。 前者的优点是查阅方便，缺点是每个人都要抄一份笔记。 后者的优点是一份笔记可以供多人使用，节省了资源，缺点是查询时较为麻烦。 SqlSessionFactoty可以看做数据库连接池 SqlSession是池中的连接对象 mapper标签返回的结果通过映射变成一个实体类对象，如果此时实体类中字段名和数据库中不符，就会导致实体类中不一致的字段无法获得值 别名在总配置文件中写，在XXXmapper.xml文件中就可以 choose标签中每次只能走一条when标签支线 foreach标签中的collection属性填入变量名，如果传入的参数是list类型，那么变量名默认为list，如果传入map类型，那么这里就需要填写map中的字段名，这个字段应该是一个list类型 缓存 你有一个密码箱，里面存着你的现金。 每次打开密码箱都需要非常繁琐的步骤。 如果每次要用钱的时候都去密码箱里取，那么会非常麻烦。 所以你想了一个办法，买了一个小腰包，每次从密码箱里多取一点，放在腰包里，这样一来，平时用钱时只需要从随声腰包里取即可，节省了大量的时间。 不过有两个缺点： 你需要承担腰包的额外支出 钱放在腰包里降低了安全性 减少和数据库的交互次数，减少系统开销，提高系统效率 ==经常查询且不经常改变的数据【可以使用缓存】== 一级缓存：SqlSession级别的缓存 1SqlSession sqlSession = MyBatisUtils.getSqlSession();2// 一级缓存作用域3sqlSession.close(); 二级缓存：namespace级别的缓存 1&lt;mapper namespace=\"com.kasim.mapper.BlogMapper\"&gt;2 &lt;!--二级缓存作用域--&gt;3&lt;/mapper&gt; 测试一级缓存同样的查询执行两次首先，打开mybatis的日志输出： 1&lt;settings&gt;2 &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;3&lt;/settings&gt; 然后写测试代码： 1SqlSession sqlSession = MyBatisUtils.getSqlSession();2UserMapper mapper = sqlSession.getMapper(UserMapper.class);34User user1 = mapper.queryUserById(1);5System.out.println(\"*********************\");6User user2 = mapper.queryUserById(1);78System.out.println(user1 == user2);9sqlSession.close(); 这里省略了实体类和mapper接口、xml配置细节，专注于对缓存的测试。 然后有了下面的输出日志： 1Opening JDBC Connection2Created connection 1882349076.3Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@70325e14]4==&gt; Preparing: select * from user where id = ? 5==&gt; Parameters: 1(Integer)6&lt;== Columns: id, name, pwd7&lt;== Row: 1, kasim, kasim8&lt;== Total: 19*********************10true11Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@70325e14]12Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@70325e14]13Returned connection 1882349076 to pool. 首先看第10行，输出了true，说明user1和user2是同一个对象，他们的内存地址相同。 然后观察从第一行打开JDBC连接，到第13行将连接返回到连接池的之间的过程当中，==sql只执行了一次(4-8行)==。而且是在”*“之前进行的，说明只有第一次的queryUserById操作检索了数据库，而后面的操作直接从缓存中获取。 不同的查询执行两次而如果将两次操作的id改为不同： 1SqlSession sqlSession = MyBatisUtils.getSqlSession();2UserMapper mapper = sqlSession.getMapper(UserMapper.class);34User user1 = mapper.queryUserById(1);5System.out.println(\"*********************\");6// 原来的1改为了27User user2 = mapper.queryUserById(2);8System.out.println(user1 == user2);9sqlSession.close(); 那么日志信息如下： 1Opening JDBC Connection2Created connection 1882349076.3Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@70325e14]4==&gt; Preparing: select * from user where id = ? 5==&gt; Parameters: 1(Integer)6&lt;== Columns: id, name, pwd7&lt;== Row: 1, kasim, kasim8&lt;== Total: 19*********************10==&gt; Preparing: select * from user where id = ? 11==&gt; Parameters: 2(Integer)12&lt;== Columns: id, name, pwd13&lt;== Row: 2, gy, gy14&lt;== Total: 115false16Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@70325e14]17Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@70325e14]18Returned connection 1882349076 to pool. 很明显sql语句执行了两次，两次获取的对象也不一样。 相同的查询之间加入更新操作按照官方文档的说法，更新或者插入操作会重置缓存，测试代码如下： 1User user1 = mapper.queryUserById(1);2System.out.println(\"*********************\");3// 加入更新操作，更新第二条数据4mapper.updateUser(2);5System.out.println(\"$$$$$$$$$$$$$$$$$$$$$\");6User user2 = mapper.queryUserById(1);7System.out.println(user1 == user2); 这里更新了第二条数据，并没有改变第一条数据，主要是为了控制变量。日志如下： 1==&gt; Preparing: select * from user where id = ? 2==&gt; Parameters: 1(Integer)3&lt;== Columns: id, name, pwd4&lt;== Row: 1, kasim, kasim5&lt;== Total: 16*********************7==&gt; Preparing: update user set name = '王重阳' where id = ? 8==&gt; Parameters: 2(Integer)9&lt;== Updates: 110$$$$$$$$$$$$$$$$$$$$$11==&gt; Preparing: select * from user where id = ? 12==&gt; Parameters: 1(Integer)13&lt;== Columns: id, name, pwd14&lt;== Row: 1, kasim, kasim15&lt;== Total: 116false 可以看到，间隔了一个更新操作之后(尽管没有修改第一条数据)，第二次的查询仍然执行了，没有直接从缓存中获取，所以最终的结果是false，user1和user2并不是同一个对象。 其实也很好理解，增删改操作可能会==改变数据==，如果不重置缓存，那么缓存里的数据可能和数据库中的不一致，这就会导致错误。 一级缓存的处理过程位置那么缓存是存在哪里的呢？打上断点开始debug： 图1. 断点调试 图2. debug信息1 可以看到，图二中的mapper对象下有一个属性methodCache，用来存放缓存。 第17行执行之前，缓存的size为0，执行第17行之后： 图3. debug信息2 发现方法被缓存了起来，此时缓存大小为1。 然后执行19行： 图4. debug信息3 发现19行执行完之后，缓存大小仍然是1，缓存并没有增加。 这是两个相同的操作，那么如果执行两次不同的查询呢？ 图5. 不同的查询测试 图6. 不同的查询测试结果 图6是执行完17、19行的debug信息，可以发现，经过两次不同的查询，缓存的大小依然是1，说明只是缓存了一个方法，传入的值并没有缓存。 ==那么只缓存方法而没有缓存传入的参数的话，就算传入同样的参数也还是需要再执行一遍sql才对==，但是实际情况是传入相同的参数并不会执行两次sql。那么只有一个可能，那就是==参数缓存在了别的地方==。 经过一番仔细的寻找，果然找到了缓存参数的地方： 图7. 缓存参数的地方 红色箭头所指的地方就是存放参数信息的地方，目前是执行17行之前的状态。 执行17行之后： 其中cache的具体信息为： 红框中的值”1”就是本次执行sql时传入的参数。 然后执行第19行： 可以看到缓存的size变成了2，新增的缓存信息为： 这里框出的2就是第二次执行sql时产生的，而后面的对象就是sql返回结果的缓存。 知道这里，终于大致明白了mybatis一级缓存的逻辑，整理一下： 缓存都以map形式存储 缓存大概分两种： 一种是方法缓存，methodCache，目的是为了让调用方法的速度更快； 第二种是对于方法具体调用信息的缓存，localCache，在方法缓存的基础之上，添加了调用方法时的参数等信息，这才是mybatis一级缓存的核心所在。 一级缓存的实现流程 方法调用时，先查看methodCache有没有缓存，如果有，则直接从缓存中拿，否则将方法加载到缓存中 查看参数信息是否在缓存localCache中，如果在，那么直接返回缓存的结果，否则将调用具体信息作为key，返回结果作为value存入localCache中。 二级缓存的处理过程搞清了一级缓存的处理过程，下面来看看二级缓存。 首先打开二级缓存开关： 1&lt;!--在mybatis-config文件配置中加上--&gt;2&lt;settings&gt;3 &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;4&lt;/settings&gt; 1&lt;!--在mapper文件配置中加上--&gt;2&lt;cache eviction=\"FIFO\" flushInterval=\"600000\" size=\"512\" readOnly=\"TRUE\"/&gt; 官方文档上说： 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。 也就是说，在一个SqlSession结束之后，缓存才能更新，当然前提是没有使用insert/delete/update语句。所以测试代码如下： 1// 获取两个SqlSession2SqlSession sqlSession1 = MyBatisUtils.getSqlSession();3SqlSession sqlSession2 = MyBatisUtils.getSqlSession();45// 每个SqlSession分别获取一个mapper对象6UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);7UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);89// 先执行一遍10User user1 = mapper1.queryUserById(1);11// 关闭sqlSession1，相当于这个sqlSession完成并提交了，提交之后缓存才能更新12sqlSession1.close();13System.out.println(\"*********************\");14// 第二次执行15User user2 = mapper2.queryUserById(1);16System.out.println(user1 == user2);17sqlSession2.close(); 接着打开debug。 上图是执行第10行之前的，mapper1中的缓存信息，可以看到上面是localCache一级缓存，而下面就是二级缓存存放位置。此时两者大小都为0。 执行第10行之后，上图1中的一级缓存中增加了信息，2中的transactionalCaches里也增加了信息，不过继续向下搜索，发现3处的cache的size为0，所以当前只是开辟了一个内存空间用来存放缓存，可是具体的值还没有放进去。 执行第12行后，sqlSession1结束并提交，所以上图2处的cache中多了一项，说明此时缓存已经真正存入内存。而反观1处一级缓存localCache中已经没有内容，说明sqlSession1结束之后，mapper1中的一级缓存已经被清除。 此时mapper2中的一级和二级缓存都为空。 执行完第15行后，SqlSession2还没有关闭并提交，但可以看到此时已经存在了二级缓存。 而且，此时mapper2的一级缓存大小为0，说明==缓存并没有被存放到一级缓存中==，因为执行语句已经在二级缓存中被找到，直接从二级缓存中获取了。 最后SqlSession2也被关闭并提交之后，二级缓存依然存在。 到这里，二级缓存的大概执行流程也搞清了，总结一下 二级缓存作用域范围更广，存在于整个命名空间之内，凌驾于SqlSession之上，SqlSession2关闭之后二级缓存仍然存在 SqlSession关闭之后，二级缓存才会更新 二级缓存读取优先级大于一级缓存，如果执行语句已经存在于二级缓存中，那么就不会再次将其加入一级缓存当中，以节省空间。 缓存流程整理 打开Sqlsession 执行方法 如果方法信息已经存在于二级缓存中的key中，那么直接获取缓存中的value，并返回，跳到步骤6 如果方法信息存在于一级缓存的key中，那么直接获取value并返回，跳到步骤6 如果缓存中没有方法信息，那么从数据库中获取信息，返回结果并将结果存放到一级缓存中，跳到步骤6 如果还有其他操作，跳到步骤2 关闭Sqlsession 将一级缓存中的内容存放到二级缓存中，然后清空一级缓存 回到第1步 流程图如下："},{"title":"","date":"2020-06-16T09:06:12.150Z","updated":"2020-06-16T09:06:12.150Z","comments":true,"path":"to_be_posted/数据结构/递归.html","permalink":"kasimg.github.io/to_be_posted/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%92%E5%BD%92.html","excerpt":"","text":"递归1. 递归模板1public void recur(int level, int param) &#123;2 // 1. 递归终止条件3 if (level &gt; MAX_LEVEL) return;4 5 // 2. 处理当层逻辑6 process(level, param);7 8 // 3. 进入下一层9 recur(level + 1, newParam);10 11 // 4. 清理当前层12&#125; 2. 要点 抵制人肉递归 不要在纸上画递归树 找最近重复性 数学归纳法思维"},{"title":"","date":"2020-06-29T03:51:07.851Z","updated":"2020-06-29T03:51:07.851Z","comments":true,"path":"to_be_posted/数据结构/数组.html","permalink":"kasimg.github.io/to_be_posted/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84.html","excerpt":"","text":"频繁在头尾增减，arraylist &gt; linkedlist，因为linkedlist增加时需要创建新的节点，而arraylist只需要向数组内存放元素 foreach 遍历collection时，不能同时对collection做增减"},{"title":"","date":"2020-06-30T04:47:42.511Z","updated":"2020-06-19T09:34:06.185Z","comments":true,"path":"to_be_posted/设计模式/建造者模式.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"建造者模式 你想造一幢房子。 工厂模式是： 有很多施工队，每个施工队只能造某一种房子，你想要什么房子，就找对应的施工队。 每个施工队的建造流程都可能不相同。 建造者模式是： 有一个实力强劲的施工队，其中有一个包工头，包工头手下有各种掌握不同技能的工人。 这个包工头掌握了一套流程，ABCD四步造出一个房子。 通过让不同的工人来做每一步，就可以造出各种各样的房子。 你只需要告诉这个包工头你需要造哪种房子即可。 下面来看代码，首先定义一个抽象类： 1public abstract class Builder &#123;2 abstract void firstStep();34 abstract void secondStep();56 abstract void thirdStep();78 abstract void forthStep();910 abstract Building getBuilding();11&#125; 这个抽象类中定义了四个步骤，代表建造房子的一套流程；另外还有一个getBuilding方法，用于获取建造好的房子。 设计好了流程，下面需要工人来干活了： 1public class Worker extends Builder &#123;23 Building building;45 public Worker() &#123;6 building = new Building();7 &#125;89 @Override10 Building getBuilding() &#123;11 return building;12 &#125;1314 @Override15 void firstStep() &#123;16 System.out.println(\"打地基\");17 &#125;1819 @Override20 void secondStep() &#123;21 System.out.println(\"钢筋工程\");22 &#125;2324 @Override25 void thirdStep() &#123;26 System.out.println(\"铺电线\");27 &#125;2829 @Override30 void forthStep() &#123;31 System.out.println(\"粉刷\");32 &#125;33&#125; Worker类里具体实现了四个步骤。 工人有了，现在需要包工头来指挥： 1public class Director &#123;2 public Building build(Worker worker) &#123;3 worker.firstStep();4 worker.secondStep();5 worker.thirdStep();6 worker.forthStep();78 return worker.getBuilding();9 &#125;10&#125; 包工头类中定义了一个方法build，接受一个worker作为参数，相当于要来指挥这个worker干活。 这里有两个关键点： 可以传入不同的worker，不同的worker对于某个步骤的具体实现可以完全不同。甚至可以传入多个worker，来搭配完成各种各样的需求 步骤可以打乱顺序，包工头可以使用任意的顺序来组合流程 最后来测试一下： 1Director director = new Director();2director.build(new Worker());34// 打印信息5打地基6钢筋工程7铺电线8粉刷 上述建造房子过程中，用户并不知道房子的具体建造流程。 ==有些时候，用户希望自己能够控制流程==，来精确实现自己的需求，这个时候，用户自己就成了director。 现在你进入了一家KFC。 你想要自己定制一份专属套餐，于是你向服务员说出了你想要的食物1234… 这里的服务员可以看做worker，最终的套餐可以看做房子，而你，正是director。 下面看代码，首先创建一个Builder抽象类： 1public abstract class Builder &#123;2 // 一个套餐包含四个部分3 abstract Builder orderA(String food);45 abstract Builder orderB(String food);67 abstract Builder orderC(String food);89 abstract Builder orderD(String food);1011 abstract SetMenu getSetMenu();12&#125; 其中实现了4个方法，分别对应点套餐的4个部分。另外还有获取最终套餐的方法。 下面定义套餐类： 1public class SetMenu &#123;2 // 默认套餐3 private String foodA = \"香辣鸡腿堡\";4 private String foodB = \"中杯可乐\";5 private String foodC = \"新奥尔良烤翅\";6 private String foodD = \"上校鸡块\";78 // 将套餐的A部分换成自定义食物9 public void setFoodA(String food) &#123;10 this.foodA = food;11 &#125;1213 public void setFoodB(String food) &#123;14 this.foodB = food;15 &#125;1617 public void setFoodC(String food) &#123;18 this.foodC = food;19 &#125;2021 public void setFoodD(String food) &#123;22 this.foodD = food;23 &#125;2425 // 用于展示菜单26 @Override27 public String toString() &#123;28 return \"SetMenu&#123;\" +29 \"foodA='\" + foodA + '\\'' +30 \", foodB='\" + foodB + '\\'' +31 \", foodC='\" + foodC + '\\'' +32 \", foodD='\" + foodD + '\\'' +33 '&#125;';34 &#125;35&#125; 这里首先定义了一组默认食物，如果用户不希望自定义套餐，那么就会提供默认套餐。 菜单类中还有4个方法，用来自定义套餐的各个部分。 下面有请服务员出场： 1public class Waitor extends Builder &#123;23 private SetMenu setMenu;45 public Waitor() &#123;6 setMenu = new SetMenu();7 &#125;89 @Override10 Builder orderA(String food) &#123;11 setMenu.setFoodA(food);12 // 这里返回本身，为了方便连续点餐13 return this;14 &#125;1516 @Override17 Builder orderB(String food) &#123;18 setMenu.setFoodB(food);19 return this;20 &#125;2122 @Override23 Builder orderC(String food) &#123;24 setMenu.setFoodC(food);25 return this;26 &#125;2728 @Override29 Builder orderD(String food) &#123;30 setMenu.setFoodD(food);31 return this;32 &#125;3334 @Override35 SetMenu getSetMenu() &#123;36 return setMenu;37 &#125;38&#125; 服务员类继承了建造者类，其中实现了4个方法，用来接收用户的需求，并改变菜单中的食物种类。 这里每次点餐之后都返回了实例本身，这样一来就可以==链式调用==，方便了用户连续点餐。 最后让我们请出包工头..不对，现在已经不需要包工头了，用户自己就是包工头： 1// 招呼服务员过来点餐2Waitor waitor = new Waitor();34// 先来个默认套餐5SetMenu setMenu = waitor.getSetMenu();67// 看看套餐的内容8System.out.println(setMenu);910// 打印信息11// SetMenu&#123;foodA='香辣鸡腿堡', foodB='中杯可乐', foodC='新奥尔良烤翅', foodD='上校鸡块'&#125; 可以看到，这里并没有director对象，那么如果需要改变套餐内容，就要想下面这样做： 1// 更喜欢吃鱼 不想喝可乐2waitor.orderA(\"芝士鳕鱼鸡腿堡\").orderB(\"大杯雪碧\");34System.out.println(setMenu);5// SetMenu&#123;foodA='芝士鳕鱼鸡腿堡', foodB='大杯雪碧', foodC='新奥尔良烤翅', foodD='上校鸡块'&#125; 虽然没有director，但还是完成了菜单的变更。 只要对服务员说出你想吃的食物就行，套餐的所有内容都由用户决定，用户就是director。 这里也暗含了==控制反转 ==的思想。 总结优点： 对象的建造和使用分离，实现解耦，客户端不需要知道产品的内部组成和实现细节 产品创建步骤由不同的方法实现，过程清晰明了 建造者类相互独立，有利于系统扩展 缺点： 创建的产品需要有较多的共同点，才能抽象出通用的建造流程。不适用产品间差异大的场景 如果产品足够复杂，那么会导致代码量巨大，系统变得臃肿"},{"title":"","date":"2020-06-30T03:57:13.640Z","updated":"2020-05-27T09:29:53.806Z","comments":true,"path":"to_be_posted/设计模式/工厂模式.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"工厂模式1. 静态工厂（简单工厂） 你想出国旅游，可是你只会讲中文。 你可以从头开始学习一门语言，直到能使用这门语言正常交流，再出国。 那么如果你想去的国家不止一个，而且这些国家都说不同的语言呢？每次出国前都需要学一门新语言，成本实在太高。 你大可以买一台翻译机。你要做的只是对着它说出中文，它就会返回给你各种各样的语言。极大降低了你打成目标的成本。 这里的翻译机就相当于一个工厂，你只需要告诉工厂，到底把你说的话翻译成哪国语言，它就会把翻译后的语言返回给你。 你根本不需要关心它是如何翻译的。 这就是静态工厂模式。 和代理模式类似，都是使用第三个对象来简化操作，区别在于前者是用来包装某些方法，后者是用来创建对象 使用者不关心具体的类的创建过程，比如有大量的参数需要传递，那么工厂模式就可以大大简化创建过程 增加新产品时必须更改原来的代码，不符合开闭原则 下面看代码： 1public class Translator &#123;2 String language;34 public Translator(String language) &#123;5 this.language = language;6 &#125;78 public void translate() &#123;9 System.out.println(\"将中文翻译成: \" + language);10 &#125;11 12 // ...省略各种参数和配置13&#125; 首先定义了一个Translator类代表翻译机。翻译机的属性language表示它可以翻译的语言类型，方法translate用来打印信息。 然后定义一个工厂类： 1public class TranslatorFactory &#123;2 private static Translator translator;34 public static Translator getTranslator(String language) &#123;5 if (language == \"英语\") &#123;6 translator = new Translator(\"English\");7 // ...省略一大堆配置8 &#125; else if (language == \"日语\") &#123;9 translator = new Translator(\"Japanese\");10 // ... 同样省略一大堆配置11 &#125;12 return translator;13 &#125;14&#125; 工厂类提供一个静态的getTranslator方法，返回一个Translator实例。 这了使用了if判断条件来创建实例，而没有使用下面这种方式： 1translator = new Translator(language); 因为要配置一个翻译机，并不是简简单单给一个语言的名字就行，而是需要大量的配置(这里省略…)。 这里的翻译机相当于只实现了两种语言的翻译。 接下来在测试类中测试： 1// 通过工厂类的静态方法获取相应的翻译机实例对象2Translator englishTranslator = TranslatorFactory.getTranslator(\"英语\");34// 打印信息5englishTranslator.trans(); 可以看到，在上面的例子当中，用户需要知道的之后“英语”两个字，就能获取一个翻译机，并不需要知道翻译机内部是如何配置的。 这就实现了使用者和创建者之间的耦合关系，使用者不需要关心实例如何创建，只需要专注于使用即可。 2. 工厂方法模式 上面的静态工厂模式有一个问题，就是一台翻译机能够翻译的语言是有限的。 万一需要翻译一门新的语言，就需要更改其内部结构，使它能支持新的语言，这很麻烦。 所以你需要新买一台新的、能支持新语言的翻译机。 每台翻译机支持特定的语言，需要翻译哪些语言就买对应的翻译机，这就是工厂方法模式。 这个模式又会带来新的问题，那就是会大大增加你的开销。 比如现在不仅需要翻译机能翻译英语和日语，还需要它翻译阿拉伯语，如果用上面的静态工厂模式，就需要在TranslatorFactory内部做改动，加上对阿拉伯语的配置逻辑，这就不符合开闭原则。 那么就有了工厂方法模式，就是为每一种翻译机配备一个工厂类。相当于如果需要翻译新的语言，那么就得新买一台翻译机。 下面来看下代码，首先定义一个工厂类接口： 1public interface TranslatorFactory &#123;2 // 工厂类需要能生产翻译机对象3 Translator getTranslator();4&#125; 接着定义一个专门生产英语翻译机的工厂类： 1public class EnglishTranslatorFactory implements TranslatorFactory &#123;2 @Override3 public Translator getTranslator() &#123;4 // ...省略大量配置5 return new Translator(\"english\");6 &#125;7&#125; 那么，我们需要英语翻译机时，就直接找EnglishTranslatorFactory工厂去生产即可： 1Translator translator = new EnglishTranslatorFactory().getTranslator();2translator.translate(); // 打印 “将中文翻译成: english” 这样的好处是，当我们有新语言翻译需求时，不需要改变原来的代码，只需要增加一个工厂类即可： 1public class ArabicTranslatorFactory implements TranslatorFactory &#123;2 @Override3 public Translator getTranslator() &#123;4 return new Translator(\"Arabic\");5 &#125;6&#125; 如此操作的好处是遵循了开闭原则，提高程序的可扩展性。而缺点则是对于每一种语言就需要有一个对应的工厂类，增加了代码量。"},{"title":"","date":"2020-06-30T05:53:05.690Z","updated":"2020-06-30T05:53:05.690Z","comments":true,"path":"to_be_posted/设计模式/原型模式.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"原型模式 你花费10天精力制作了一个精美的PPT，得到了领导的赞赏。 后来你又接到了做PPT的任务，你觉得上次那种风格很赞，想再次使用。 这个时候你会从头开始，再花个10天做出一个差不多的PPT吗？ 不，你不会。 你会把之前的PPT直接拷贝一份，在此基础之上加以修改，这样效率就得到极大提升。 这就是原型模式。 原型模式就像克隆，将原本一个创建步骤很复杂的对象直接拷贝一份来代替创建，提高效率。 下面看代码： 1public class PPT implements Cloneable &#123;23 // 这里省略了7天4 private String day1 = \"疯狂做PPT中...\";5 private String day2 = \"疯狂做PPT中...\";6 private String day3 = \"疯狂做PPT中...\";7 private Date deadline; // 存放日期对象8 private SimpleDateFormat sdf; // 日期格式化对象910 public PPT(Date deadline) &#123;11 this.deadline = deadline;12 sdf = new SimpleDateFormat(\"yyyy-MM-dd\");13 System.out.println(\"开始做PPT\");14 &#125;1516 @Override17 protected Object clone() throws CloneNotSupportedException &#123;18 return super.clone();19 &#125;2021 @Override22 public String toString() &#123;23 return \"PPT&#123;\" +24 \"day1='\" + day1 + '\\'' +25 \", day2='\" + day2 + '\\'' +26 \", day3='\" + day3 + '\\'' +27 '&#125;' + \"\\n\" + sdf.format(deadline) + \"，PPT终于做好了\";28 &#125;29&#125; 这里定义了一个PPT类，实现了==Cloneable==接口，只要实现了这个接口，这个类的实例对象就能调用克隆方法克隆自身。 下面测试： 1Date deadline = new Date(100, 1, 1);23PPT ppt1 = new PPT(deadline);4System.out.println(ppt1);5System.out.println(ppt1.hashCode());67System.out.println(\"################################\");89PPT ppt2 = (PPT) ppt1.clone();10System.out.println(ppt2);11System.out.println(ppt2.hashCode());1213// 打印信息14// 开始做PPT15// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;16// 2000-02-01，PPT终于做好了17// 122941651418// ################################19// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;20// 2000-02-01，PPT终于做好了21// 2016447921 首先看17和21行，发现hashcode并不相同，说明ppt1和ppt2是两个完全不同的对象。 然后看第14行，ppt1创建时调用了构造方法，而克隆ppt2时并没有调用，说明clone确实不是直接创建。 最后看第15和19行，发现内容确实相同，达到了克隆的效果。 乍一看，到这里克隆就已经结束了。不过这样的克隆是有问题的。现在改变deadline的值： 1Date deadline = new Date(100, 1, 1);23PPT ppt1 = new PPT(deadline);4PPT ppt2 = (PPT) ppt1.clone();5System.out.println(ppt1);6System.out.println(\"\\n\");7System.out.println(ppt2);89System.out.println(\"################change deadline################\");1011// 改变deadline的值12deadline.setYear(101);13System.out.println(ppt1);14System.out.println(\"\\n\");15System.out.println(ppt2);1617// 打印信息18// 开始做PPT19// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;20// 2000-02-01，PPT终于做好了2122// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;23// 2000-02-01，PPT终于做好了24// ################change deadline################25// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;26// 2001-02-01，PPT终于做好了2728// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;29// 2001-02-01，PPT终于做好了 可以看到，更改日期之后，两个对象的deadline都从2000-02-01变成了2001-02-01。说明==两个对象共用一个date对象==。放到内存中看，就是两个PPT实例中的deadline指针指向同一个date对象。 此时，改变deadline对象会导致所有克隆出来的实例中的deadline对象发生改变，这有可能引发一系列问题。 假设用羊A克隆出了羊B，羊A和羊B需要共用一颗心脏，那么显然是不合理的。 所以这种不完全的克隆并不是真正的克隆，也称之为==浅克隆==。 下面实现依稀简单的“深克隆”： 1protected Object clone() throws CloneNotSupportedException &#123;2 PPT ppt = (PPT) super.clone();3 4 // 将date对象也克隆一次5 ppt.deadline = (Date) this.deadline.clone();6 return ppt;7&#125; 这里简单的将date对象也克隆了一次，打印结果如下： 1// 开始做PPT2// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;3// 2000-02-01，PPT终于做好了45// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;6// 2000-02-01，PPT终于做好了7// ################change deadline################8// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;9// 2001-02-01，PPT终于做好了1011// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;12// 2000-02-01，PPT终于做好了 可以看到改变之前两者日期相同，而改变deadline之后，ppt1的deadline变成了2001，而ppt2的deadline则没有改变，说明深克隆成功实现。 当然这里的所谓深克隆也并非真正的深克隆，因为如果date对象中还有引用类型的话，那么问题依然存在。"},{"title":"","date":"2020-06-30T04:59:42.363Z","updated":"2020-06-19T09:34:06.189Z","comments":true,"path":"to_be_posted/设计模式/桥接模式.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"桥接模式 你想整理一份当前市面上主流的电脑产品信息，于是画了下面一张图： 图1. 电脑信息1 乍一看，清晰明了，层次分明，可是仔细一琢磨，还是有些问题： 如果要新增一种电脑类型，比如手表电脑，那么就要在手表电脑下面再增加每种品牌的电脑个一种。 同理，如果要增加一种品牌，那么原有电脑类型下面也全都需要更新 这两个问题导致扩展非常麻烦，且扩展之后结构会越来越臃肿和复杂。 于是你转换了一下思路，又重新画了一张图： 图2. 电脑信息2 图2中横向虚线表示电脑种类，纵向虚线表示品牌，纵横交汇处的店表示某一中具体的电脑。 可以看到，如果需要添加电脑种类，只需要加一条横向虚线就会产生n个交汇点（n为品牌数），同理，增加品牌只需要增加纵向虚线即可。 这样一来就大大提升了可扩展性。 第二种图的思想就是==桥接模式==。 1. 单一职责原则在面向对象中，图1违背了==单一职责原则==。所谓单一职责原则，就是每个类只负责一项功能。 图1的第三层中，如果把“联想台式”看做一个类，那么这个类代表了2个功能：品牌和类型。 而反观图2把每一条虚线看做一个类，每个类只关注一个问题、实现一个功能，所以图2的可扩展性比图1要好。 2. 实现图2中的逻辑下面看代码，首先定义品牌接口： 1public interface Brand &#123;2 String brandInfo();3&#125; 品牌类中只定义了一个方法，目的是返回品牌名称的字符串。 接着定义具体的品牌类： 1public class Lenovo implements Brand &#123;2 @Override3 public String brandInfo() &#123;4 return \"联想牌\";5 &#125;6&#125;7// 其他省略... 然后定义类型接口和类型实现类： 1// 类型接口2public interface Type &#123;3 String typeInfo();4&#125;56// 实现类7class PC implements Type &#123;8 @Override9 public String typeInfo() &#123;10 return \"台式\";11 &#125;12&#125;1314// 其余省略... 接下来定义电脑类： 1public class Computer &#123;2 Brand brand;3 Type type;45 public Computer(Brand brand, Type type) &#123;6 this.brand = brand;7 this.type = type;8 &#125;910 public void computerInfo() &#123;11 System.out.println(brand.brandInfo() + type.typeInfo());12 &#125;1314&#125; 电脑类有两个属性，品牌和类型（可以看做在图2中横纵各取一条虚线），构造函数给两个属性赋值，还有一个用于打印信息的函数。 最后来测试： 1// 用品牌和类型创建一个电脑实例2Computer computer = new Computer(new Lenovo(), new PC());34// 打印电脑信息: 联想牌台式5computer.computerInfo(); 这里用品牌和类型创建了一个电脑实例，相当于在图2中两条虚线交汇形成了一个点。 到此为止，图2中表现的内容就用代码比较好地实现了出来。 3. 改进如果只是想表达图2的意思的话，到上一步就可以了，不过如果仔细思考，就会发现此时还有一个问题： 在实际情况下，不同类型的电脑具体实现逻辑大概率不同，如果只实现了一个Computer类，那么很难对这些进行区分。比如平板需要实现触摸功能，而台式机几乎不需要触屏功能；再比如，ios和android平板和主流笔记本以及台式机的操作系统不一样，所以这方面也应该区别对待。 于是考虑将computer作为父类，将具体型号的电脑作为子类来实现各自的功能。 下面看代码，品牌接口和实现类不变，首先改变Computer类： 1public abstract class Computer &#123;2 // 品牌3 Brand brand;45 public Computer(Brand brand) &#123;6 this.brand = brand;7 &#125;89 // 抽象方法，具体实现由子类完成10 abstract public void computerInfo();1112&#125; 和之前不同的是，这里的电脑类变成了抽象类，保留了品牌信息，定义了一个抽象方法，其具体实现由子类完成。 然后定义子类： 1class PC extends Computer &#123;23 public PC(Brand brand) &#123;4 super(brand);5 &#125;67 @Override8 public void computerInfo() &#123;9 // 省略大量关于PC的操作10 System.out.println(brand.brandInfo() + \"台式\");11 &#125;12&#125;13// 其余省略... 可以看到，在子类中重写了computerInfo方法，这里就可以加入各种PC独有的逻辑。 下面测试： 1// 创建电脑实例2Computer computer = new PC(new Lenovo());34// 打印信息: 联想牌台式5computer.computerInfo(); 和前面不一样的是，这里用子类来实例化对象，再用多态存放实例。 到此为止，不仅图2的思想得到了实现，也更符合实际情况。 4. 总结优点： 减少子类个数，降低维护成本。比如图1中，有3个一级子类，9个二级子类，而图2中只有6个。再抽象一点，图1中类的空间复杂度为O(m~1~ m~2~ … * m~k~)，图2的空间复杂度为O(m~1~ + m~2~ + … + m~k~)，其中k为维度（在这里就是品牌和电脑种类），m~k~为维度的长度（比如品牌有3种）。如果维度很多的话，桥接模式能够极大减少类的数量。 增强可扩展性。 缺点： 增加系统的理解与设计难度。 需要系统能够分离出一系列正交的维度（个个维度之间互不相关），对于强耦合的维度不使用。"},{"title":"","date":"2020-05-27T07:53:26.616Z","updated":"2020-05-27T07:53:26.616Z","comments":true,"path":"to_be_posted/设计模式/概念.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A6%82%E5%BF%B5.html","excerpt":"","text":"面向对象设计原则的时机运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。 基本要素 模式名称 问题 解决方案 效果 OOP七大原则 开闭原则：对扩展开放，对修改关闭 里式替换原则：继承必须确保父类所拥有的性质在子类中仍然成立 依赖倒置原则：面向接口而不要面向实现编程"},{"title":"","date":"2020-06-30T04:01:24.473Z","updated":"2020-06-19T09:34:06.186Z","comments":true,"path":"to_be_posted/设计模式/抽象工厂模式.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"抽象工厂模式 你需要买手机。 去数码城找中间商选你喜欢的牌子买，这叫简单工厂模式。 喜欢什么牌子，去对应的专卖店买，这叫工厂方法模式。 图1 简单工厂模式和工厂方法模式 上面的两种模式都是针对单一产品而言的，如果有多种产品呢？考虑到可扩展性，这里采用工厂方法模式进行扩展。 可以在工厂方法模式的基础上加别的产品的接口 比如这样： 1public class HuaweiFactory implements PhoneProductor, RouterProductor, PadProductor... 可以看到，如果产品种类不多的话，直接扩展还可以接受，但是如果产品很多的话，这样写就显得非常的不美观、不简洁、不优雅。 使用更优雅的写法。 于是就想到，可不可以只实现一个接口，在这个接口中定义所有的生产产品的方法呢？ 当然可以，这就是==抽象工厂模式==。 首先，定义一个抽象工厂类： 1public interface AbstractProductFactory &#123;2 // 生产手机3 Phone productPhone();45 // 生产路由器6 Router productRouter();7&#125; 这个抽象工厂目前有两个功能，生产手机和生产路由器。 接下来定义手机和路由器两个产品： 1public interface Phone &#123;2 void start();34 void shutDown();56 void dial();78 void text();9&#125;1011public interface Router &#123;12 void start();1314 void shutDown();1516 void setting();17&#125; 然后定义4个产品实现类，分别是小米手机、小米路由器、华为手机、华为路由器： 1public class XiaomiPhone implements Phone &#123;2 @Override3 public void start() &#123;4 System.out.println(\"开启小米手机\");5 &#125;67 @Override8 public void shutDown() &#123;9 System.out.println(\"关闭小米手机\");10 &#125;1112 @Override13 public void dial() &#123;14 System.out.println(\"使用小米手机拨号\");15 &#125;1617 @Override18 public void text() &#123;19 System.out.println(\"使用小米手机发短信\");20 &#125;21&#125;22// 其余的代码省略... 接下来要定义两个抽象工厂的实现类：小米工厂和华为工厂： 1public class XiaomiFactory implements AbstractProductFactory &#123;2 @Override3 public Phone productPhone() &#123;4 return new XiaomiPhone();5 &#125;67 @Override8 public Router productRouter() &#123;9 return new XiaomiRouter();10 &#125;11&#125;12// 华为工厂省略... 这样一来，每个工厂类只需要实现一个接口即可。 后续添加产品也非常方便，只需要加上产品接口，然后在抽象工厂类AbstractProductFactory中添加接口即可，工厂类完全不需要改动。 总结一下三种工厂模式 模式名称 优点 缺点 适用场景 简单工厂模式 简单，代码量少 可扩展性低 产品较少，无扩展需求 工厂方法模式 可扩展性较高 代码量较多 产品较少，有扩展需求 抽象工厂模式 可扩展性高 代码量多 产品较多，有扩展需求 最后说一句：没有最好的模式，只有最适合的模式。"},{"title":"","date":"2020-06-30T05:49:44.510Z","updated":"2020-06-19T09:34:06.190Z","comments":true,"path":"to_be_posted/设计模式/适配器模式.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"适配器模式 你买了一台新笔记本电脑，兴奋地拆开包装，连上电源，插上网线…等等？为什么没有网线接口？？ 你无奈地看着轻薄的机身和type-c接口，陷入了沉思。 你是个游戏玩家，更喜欢网线直连带来的稳定急速游戏体验，于是你决定买一个适配器。 通过适配器串联type-c接口和网线，这就是适配器模式。 1. 类适配器下面看代码，首先定义一个网线类，用来连接网络。 1public class Cable &#123;2 public void request() &#123;3 System.out.println(\"连接网线上网\");4 &#125;5&#125; 接着定义转换器接口，这个接口只有一个方法，就是适配。 1public interface Adapter &#123;2 void adapt(); // 适配方法3&#125; 随后定义一个实现接口的具体适配器，这里是typec适配器。 1public class TypecAdapter extends Cable implements Adapter &#123;2 @Override3 public void adapt() &#123;4 super.request();5 &#125;6&#125; 注意到此处的TypecAdapter不仅实现了适配器接口，还继承了网线类Cable，这样一来，适配器类就可以使用父类网线类的方法，这种适配模式也被称作为==类适配器模式==。 现在是时候拿出电脑来了： 1public class Computer &#123;2 // 需要转接头才能上网3 public void onlineSurfing(TypecAdapter typecAdapter) &#123;4 typecAdapter.adapt();5 &#125;6&#125; 这里的Computer类实现了一个上网的方法，接受一个转接头作为参数，通过转接头的适配方法，打通电脑和网线之间的通道。 最后测试： 1Computer computer = new Computer();2computer.onlineSurfing(new TypecAdapter());34// 打印信息5// 连接网线上网 成功上网。 不过这种适配模式有几个问题： 如果需要继承的类发生改变，那么需要直接改动代码，不符合开闭原则，灵活性降低。 java具有单继承性，这种模式下，每种适配器只能继承一个类，如果需要适配的对象超过两个，那么就不能用这种方式实现。 测试样例中根本没有出现Cable类，只有TypecAdapter类，Cable类被集成到了TypecAdapter类中，作用以及角色被淡化，导致代码的表现力不佳。 2. 对象适配器为了解决上述的问题，现在对于TypecAdapter作修改： 1public class TypecAdapter implements Adapter &#123;2 // 将cable作为可以插拔的接口3 private Cable cable;45 // 相当于在适配器接口中插入相应的网线6 public void setCable(Cable cable) &#123;7 this.cable = cable;8 &#125;910 @Override11 public void adapt() &#123;12 cable.request();13 &#125;14&#125; 首先，这里将cable作为属性保存在适配器类中，相当于在适配器上创建了一个可以插网线的接口。 其次，实现了setCable方法，接受一个Cable类型的参数，调用这个方法相当于向插槽中插入了网线。 下面测试： 1Computer computer = new Computer();23// 加入对cable的显示定义4Cable cable = new Cable();56// 创建适配器并且将网线插入插槽7TypecAdapter typecAdapter = new TypecAdapter();8typecAdapter.setCable(cable);910computer.onlineSurfing(typecAdapter);1112// 打印信息13// 连接网线上网 这里解决了上述的三个问题： 如果接口发生改变，只需要在原有基础上，向TypecAdapter类中加入新的“插槽”即可，不需要改变原来的代码 同理，如果有多个对象需要适配，那么直接增加即可 setCable(cable)显示调用，表明将网线插入插槽，代码表现力和可读性增强。 3. 总结 适配器模式将原本由于接口不兼容而无法协同的类可以在一起工作。 适配器模式有以下几种角色： 目标接口。也是用户期望的接口，就是这里的typec接口。 适配对象。需要被适配的接口，就是这里的网线接口。 适配器。适配1和2的装置，就是这里的typec适配器。 适用场景： 系统中有些老的类，接口或者方法名已经不符合现有要求。 将彼此关联性小的一些类通过适配器获得协同工作的能力。"},{"title":"","date":"2020-06-30T03:48:46.161Z","updated":"2020-06-30T03:48:46.161Z","comments":true,"path":"to_be_posted/设计模式/单例模式.html","permalink":"kasimg.github.io/to_be_posted/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html","excerpt":"","text":"单例模式 你每天放学回家之后，都会把所有的课本全都扔掉，然后再全部买一本新的。 你为了买书省吃俭用，很快，你每天的午餐从二荤三素变成了一个馒头。 因为你每天都用新书，之前在书上记的笔记全都丢失了，完全没法复习，除非你每天都把之前的笔记全都抄一遍。 你图啥呢？ 所以更加合理的做法是，一学期只用一本书，这本书保留你做的所有笔记。 一学期用一本书就是单例模式。 单例模式主要用来节省资源，以及保留一些全局的信息。 1. 饿汉式 今天第八节是语文课。 你在上第一节课的时候，就把语文课本摊开放在桌上，为了语文课做准备。 事先摊开课本会导致你其他科目的课本没有足够的地方放，降低了学习效率。 对应到代码： 1class HungryMan &#123;2 // 私有化构造函数，使得无法用new构造实例3 private HungryMan() &#123;&#125;45 // 创建静态不可变的对象实例6 private final static HungryMan HUNGRY_MAN = new HungryMan();78 // 静态公共方法获取单例对象9 public static HungryMan getInstance() &#123;10 return HUNGRY_MAN;11 &#125;12&#125; 可以看到这里事先创建了一个实例对象，用户只能使用类的getInstance方法获取这个实例，而且每次获取的都是同一个实例。 这就简单地完成了单例模式。 不过这种做法有个缺点，就像上面的例子中说的，实例对象在获取实例之前被创建，在调用getInstance之前白白占用了资源。 2. 懒汉式 你只有在上课之前才会把相应科目的课本摊开放在桌上。 为了解决饿汉式单例模式所暴露出的问题，新的单例模式”懒汉式”出现了。代码如下： 1class LazyMan &#123;2 private LazyMan() &#123;&#125;34 // 因为要在使用时才创建，需要重新赋值，所以不能用final5 private static LazyMan LAZY_MAN;67 public static LazyMan getInstance() &#123;8 // 如果之前没有创建过，那么就创建一个新的实例然后返回9 // 否则直接返回10 if (LAZY_MAN == null) &#123;11 LAZY_MAN = new LazyMan();12 &#125;13 return LAZY_MAN;14 &#125;15&#125; 可以看到，懒汉式和饿汉式的区别就在于前者只有在需要的时候才创建，而后者无论需不需要都事先创建。 前者能解决资源占用问题，不过也带来了一个新的问题：==线程不安全== 首先创建一些进程： 1for (int i = 0; i &lt; 10; i++) &#123;2 new Thread(() -&gt; &#123;3 LazyMan.getInstance();4 &#125;).start();5&#125; 然后加上一些打印信息： 1private LazyMan() &#123;2 System.out.println(Thread.currentThread().getName() + \" init instance\");3&#125; 运行程序，打印信息如下： 1Thread-6 init instance2Thread-5 init instance3Thread-0 init instance4Thread-7 init instance5Thread-2 init instance6Thread-1 init instance7Thread-3 init instance8Thread-4 init instance 可以看到，有超过一个线程进入了构造方法，说明有多个实例被创建，这就使得单例模式变得毫无意义。 于是把获取实例的方法改成同步方法： 1public synchronized static LazyMan getInstance() &#123;2 if (LAZY_MAN == null) &#123;3 LAZY_MAN = new LazyMan();4 &#125;5 return LAZY_MAN;6&#125; 这样的话，才完成了一个线程安全的单例模式。 不过问题还没有结束，虽然线程安全了，但是==反射==机制仍然能破坏单例模式： 1// 正常获取实例2LazyMan instance = LazyMan.getInstance();34// 通过反射获取无参构造器信息5Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);67// 获取通行证，接下来可以越过任何私有访问限制8declaredConstructor.setAccessible(true);910// 通过反射创建一个新的实例11LazyMan instance2 = declaredConstructor.newInstance();1213// 打印一下两个实例的信息14System.out.println(instance);15System.out.println(instance2); 打印信息如下： 1com.kasim.designPattern.LazyMan@61bbe9ba2com.kasim.designPattern.LazyMan@610455d6 可以看到，两个实例的内存地址不一样，说明是两个不同的实例，所以，==反射破坏了单例模式== 为了防止反射从中作梗，我们需要再构造函数里加以判断： 1private LazyMan() &#123;2 // 第二层锁3 synchronized (LazyMan.class) &#123;4 if (LAZY_MAN != null) &#123;5 throw new RuntimeException(\"请不要试图破坏单例模式！\");6 &#125;7 &#125;8 System.out.println(Thread.currentThread().getName() + \" init instance\");9&#125; getInstance上的锁是为了锁住使用getInstance正常获取的线程，而构造方法中的锁是为了锁住通过反射使用构造函数的线程。 由于getInstance上的锁，同一时间只有一个线程可以进入到方法内，即只有一个线程可以使用构造方法，而如果此时有一个线程使用反射方式调用LazyMan构造方法，那么第二层锁就会生效，保证了同一时间只有一个线程能够使用LazyMan类对象的资源，也就防止了反射对于单例模式的破坏。 不过仔细观察上面的代码，不难发现在使用反射之前，就已经通过getInstance方法获取了实例，且LAZY_MAN不是空。那么如果一开始就使用反射呢？ 如果一开始就使用反射，那么LAZY_MAN根本就不会被赋值，它一直未null，所以反射每次调用构造方法都不会抛出异常。 我们需要想办法，不通过LAZY_MAN是否为空来判断实例有没有被创建。 首先想到==增加一个标志位==： 1// 增加标志位，用来判断实例是否已经被创建2private static boolean created = false; 然后根据标志位进行判断： 1private LazyMan() &#123;2 synchronized (LazyMan.class) &#123;3 if (!created) &#123;4 created = true;5 &#125; else &#123;6 throw new RuntimeException(\"请不要试图破坏单例模式！\");7 &#125;8 &#125;9 System.out.println(Thread.currentThread().getName() + \" init instance\");10&#125; 因为无论是getInstance方法，还是通过反射，都需要经过构造函数，所以第一次调用构造函数时，created一定会被置为true，下一次再调用构造函数时，就会因为已经创建过实例而抛出错误。 道高一尺魔高一丈，就算设置了标志位，反射还是获取标志位，通过改变标志位的值再次破坏单例模式 看如下代码： 1// 获取标志位字段对象2Field created = LazyMan.class.getDeclaredField(\"created\");34// 打通权限5created.setAccessible(true);67LazyMan instance2 = declaredConstructor.newInstance();89// 创建实例之后将标志位置为false10created.set(instance2, false); 如此一来，反射再次破坏了单例模式。 那么如何解决这个问题呢？目前是newInstance这个方法创建了实例，不如从这个方法入手。 于是硬着头皮点开newInstance源码，看到了下面这段代码： 1if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)2 throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); “Cannot reflectively create enum objects”的大概意思是”==无法通过反射来创建枚举对象==”。 看到这里，可谓柳暗花明又一村。 那么赶紧开始下一步行动： 1// 先定义一个枚举类2public enum EnumSingleton &#123;34 INSTANCE;5 6 private EnumSingleton() &#123;7 &#125;89 public EnumSingleton getInstance() &#123;10 return INSTANCE;11 &#125;1213&#125; 下面就要开始测试了： 1Constructor&lt;EnumSingleton&gt; declaredConstructor = EnumSingleton.class.getDeclaredConstructor(null);23declaredConstructor.setAccessible(true);45EnumSingleton enumSingleton = declaredConstructor.newInstance(); 运行之后居然报了错： 1Exception in thread \"main\" java.lang.NoSuchMethodException: com.kasim.designPattern.EnumSingleton.&lt;init&gt;() 说是没有找到构造方法。经过一番查阅资料，发现==枚举类的构造方法只有编译器能调用，无法手动调用==。 于是只能另谋出路，寻找看看有没有其他构造方法。 想到了反编译，把EnumSingleton生成的.class文件反编译成java文件，看看其中到底有没有构造方法。 使用jad反编译，得到java文件中有这样这一部分： 1private EnumSingleton(String s, int i) &#123;2 super(s, i);3&#125; 这明显是个构造方法，它有两个参数，一个是String型，一个是int型，得到这个消息之后立刻回到刚才的测试代码： 1// 改变获取构造器的方式2Constructor&lt;EnumSingleton&gt; declaredConstructor = EnumSingleton.class.getDeclaredConstructor(String.class, int.class);34// 创建实例5declaredConstructor.setAccessible(true);6EnumSingleton enumSingleton = declaredConstructor.newInstance(); 再次运行，得到下面的错误： 1Exception in thread \"main\" java.lang.IllegalArgumentException: Cannot reflectively create enum objects 和newInstance方法源码中的错误相同！！ 所以到这里为止，终于找到了一个防止反射破坏单例模式的方法：==枚举类==。 正义最终还是压制住了邪恶。 最后整理一下代码： 1public enum EnumSingleton &#123;23 // 创建枚举类型的实例4 INSTANCE(LazyMan.getInstance());56 private LazyMan lazyMan;78 // 定义构造方法，在枚举实例上存储单例对象9 private EnumSingleton(LazyMan lazyMan) &#123;10 this.lazyMan = lazyMan;11 &#125;1213 // 获取单例对象14 public static LazyMan getInstance() &#123;15 return INSTANCE.lazyMan;16 &#125;1718&#125; 到这里，终于实现了一个线程安全、漏洞较少的单例模式。"}],"posts":[{"title":"对于IOC的理解","slug":"IOC","date":"2020-05-16T03:03:04.000Z","updated":"2020-06-30T03:44:03.329Z","comments":true,"path":"2020/05/16/IOC/","link":"","permalink":"kasimg.github.io/2020/05/16/IOC/","excerpt":"什么是IOC？ 为什么要用IOC？","text":"什么是IOC？ 为什么要用IOC？ 1. 代码的稳定性1.1 开闭原则开闭原则（Open Close Principle, OCP）是指，软件对象应该对扩展开放，而对修改关闭。是软件工程领域一个非常重要的原则，它保证了代码的可扩展性和可维护性。 1.2 不稳定的代码在这里，姑且把“不符合开闭原则的代码”称为“不稳定的代码”，比如，以dota为例，下面的代码就是不稳定的： 首先定义三个个英雄类： 1// 定义一个Axe类，表示“斧王”这个英雄2// 英雄有4个主动技能3public class Axe &#123;4 public void skill1() &#123;5 System.out.println(\"Axe releases 'Berserker's Call'\");6 &#125;7 public void skill2() &#123;8 System.out.println(\"Axe releases 'Battle Hunger'\");9 &#125;10 public void skill3() &#123;11 System.out.println(\"Axe releases 'Counter Helix'\");12 &#125;13 public void skill4() &#123;14 System.out.println(\"Axe releases 'Culling Blade'\");15 &#125;16&#125;1718// 具体实现与上面类似，都是实现4个技能，这里不再赘述。19public class Kunkka &#123;&#125;20public class Zeus &#123;&#125; 假设用户通过在命令行输入的名字来选择英雄，那么逻辑如下： 1// 主函数2public static void main(String[] args) throws Exception &#123;3 System.out.println(\"Please enter a hero's name: \");4 Scanner scanner = new Scanner(System.in);5 String name = scanner.nextLine();6 7 switch (name) &#123;8 case \"Axe\": &#123;9 Axe axe = new Axe();10 axe.skill1();11 break;12 &#125;13 case \"Kukka\": &#123;14 Kunkka kunkka = new Kunkka();15 kunkka.skill1();16 break;17 &#125;18 case \"Zeus\": &#123;19 Zeus zeus = new Zeus();20 zeus.skill1();21 break;22 &#125;23 default: throw new Exception(); // 如果输入的不是定义的三个英雄的名字则抛出异常24 &#125;25&#125; 上面的逻辑，乍一看清晰明了，不过仔细揣摩之后有许多问题： 第一，英雄是会不断增加的，如果向上面这样写的话，每次增加英雄都需要改变主函数里的逻辑，现在只有一个“释放第一个技能”的逻辑，万一后面有非常多的逻辑的话，代码改动量非常大，可维护性极差。 第二，如果英雄类中的方法，或者类名发生了变化，那么这里也需要改动。 第三，不仅仅是这里用到了英雄类，其他地方也可能引用，那么一旦第一或者第二种情况发生，所有用到改动的英雄类的地方都需要改动，这是毁灭性的灾难。 基于以上三点，这段代码是不符合开闭原则的。 2. 第一次改进 — interface 在面向对象的程序中，就是不断地创建对象，然后调用对象的方法来完成逻辑。 那么，只要统一了对象的创建和方法的调用，那么代码就稳定了。 这里先解决方法的统一。 2.1用interface改进代码首先定义英雄接口： 1// 接口定义了四个方法，对应英雄的四个技能2public interface Hero &#123;3 void skill1();4 void skill2();5 void skill3();6 void skill4();7&#125; 接着让英雄类实现接口： 1// 具体实现未变，故省略2public class Axe implements Hero &#123;&#125;3public class Kunkka implements Hero &#123;&#125;4public class Zeus implements Hero &#123;&#125; 最后修改主函数： 1public static void main(String[] args) throws Exception &#123;2 System.out.println(\"Please enter a hero's name: \");3 Scanner scanner = new Scanner(System.in);4 String name = scanner.nextLine();5 Hero hero;6 switch (name) &#123;7 case \"Axe\": &#123;8 hero = new Axe();9 break;10 &#125;11 case \"Kukka\": &#123;12 hero = new Kunkka();13 break;14 &#125;15 case \"Zeus\": &#123;16 hero = new Zeus();17 break;18 &#125;19 default: throw new Exception();20 &#125;21 hero.skill1();22&#125; 可以看到，改动之后，不需要再在每个switch分支当中调用skill1方法，而是统一地在第21行调用了方法，这样一来就实现了方法调用的统一。 2.2 interface的意义2.2.1 优点使用interface主要有两个优势： 第一，精简代码。如果有100个英雄，那么这样改进就省下了将近100行代码；如果4个技能都需要调用，那么就剩下了近400行代码。 第二，面向接口编程。hero对象利用了多态，并不关注存放的具体是那个英雄，只要实现了Hero接口，那么接下来的方法调用就一定不会出错。 其中第二点当中蕴含的思想尤为重要。 2.2.2 缺点没有解决对象创建的统一。 3. 第二次改进 — 工厂模式 既然已经解决了方法统一的问题，那么就只剩下方法创建的统一了。 也就是说，把存在==new==关键字的地方统一起来，就解决了稳定性的问题。 3.1 用工厂模式改进代码首先定义英雄工厂类： 1public class HeroFactory &#123;2 // 静态方法获取英雄3 public static Hero getHero() throws Exception &#123;4 System.out.println(\"Please enter a hero's name: \");5 Scanner scanner = new Scanner(System.in);6 String name = scanner.nextLine();7 Hero hero;8 switch (name) &#123;9 case \"Axe\": &#123;10 hero = new Axe();11 break;12 &#125;13 case \"Kukka\": &#123;14 hero = new Kunkka();15 break;16 &#125;17 case \"Zeus\": &#123;18 hero = new Zeus();19 break;20 &#125;21 default: throw new Exception();22 &#125;23 return hero;24 &#125;25&#125; 可以看到，上面的代码其实就是把原来主函数当中的逻辑搬运到了HeroFactory类中，最终返回一个Hero对象。 接着改变主函数： 1public static void main(String[] args) throws Exception &#123;2 Hero hero = HeroFactory.getHero();3 hero.skill1();4&#125; 这样一来，主函数当中就消除了new关键字，可以认为初步稳定了。 3.2 工厂模式的意义3.2.1 初步稳定的局限上面提到了初步稳定，为什么是初步稳定？因为虽然没有使用new关键字实例化HeroFactory类，这里还是用到了具体的类。如果后期需要获取一个“地形对象”，那么还需要创建一个“地形工厂”，这就导致在主函数中需要增加使用地形工厂获取地形对象的语句。 这也就说明：主函数仍然会变动，不是真正的稳定。 3.2.2 超级工厂上面提到，由于工厂数量可能会增加，导致了不稳定性，那么如果有一个==超级工厂==，这个工厂里可以获取各种各样的对象，那么就不需要再增加其他工厂，也就不会导致不稳定性。 所以： 如果工厂大到可以获取任何对象，那么就能保证==主函数的稳定== 3.2.3 不稳定性的转移注意到，上面总结出来的结果是：保证主函数的稳定。只是保证了主函数部分的稳定。 其实也很好理解，因为new关键字仍然存在于工厂类中，并没有被消除。 那么这种“治标不治本”的稳定性有意义吗？ 答案是肯定的，试想一下，如果整个项目当中，有100个地方需要获取Hero对象，一旦对象创建方式发生变化，不用工厂模式的情况下，这100处就都需要修改，如果有1000，10000处使用呢（虽然夸张，但是能说明问题）？ 而使用了工厂模式的话，只有工厂类内部需要改动。 所以，工厂模式的意义就在于： 将所有不稳定性转移到同一个地方，来保证其他地方的稳定性。 4. 第三次改进 — 反射 工厂模式将所有的不稳定集中起来，保证了其他地方的稳定。 那么，只要消除了工厂中的不稳定性，就彻底消除了代码中的不稳定性。 3.1 用反射改进代码用反射形式改进工厂： 1public class HeroFactory &#123;2 // 如果输入的类名不合法，那么会b3 public static Hero getHero() throws Exception &#123;4 System.out.println(\"Please enter a hero's name: \");5 Scanner scanner = new Scanner(System.in);6 String name = scanner.nextLine();7 // 包全路径名的前缀8 String packagePath = \"com.IOC.hero.\";9 10 // 使用反射获取元类对象11 Class&lt;?&gt; HeroMeta = Class.forName(packagePath + name);1213 // 使用元类创建实例14 Hero hero = (Hero)HeroMeta.newInstance();1516 return hero;17 &#125;18&#125; 这里使用反射机制，直接通过用户传入的字符串获取了元类对象，通过元类对象创建了实例。 这样一来，工厂中的new也被消除了，这么一来，代码中的所有不稳定性就全部消除了（认为存在一个超级工厂）。 3.2 反射的优劣 优势：去除了new关键字，使得工厂中的代码真正稳定 劣势：性能较低，如果使用的地方很多，会导致系统整体效率下降。（==spring中使用缓存解决这个问题==） 3.3 重新理解不稳定性如果需要增加一个英雄，那么增加类在所难免，那么“增加类”这个操作是不是也可以认为是“不稳定”的呢？ 如果需要改变一个技能的施法动作，也就是要在skill1中改变具体的逻辑代码，这可以认为是“不稳定”吗？ 我的理解是，不能。 因为这些改动是==不可避免==的。各项数值的调整，都需要去改变具体的逻辑，这是一定的。 而前文在解决的不稳定性，都是==可以避免==的，可以通过不同的写法来避免。 根据改动是否可以避免，姑且把代码分为两类： ==业务代码==。变动不可避免的代码，具体体现为项目中具体的类的实现，随着需求改变不断改变。 ==控制代码==。变动可以避免的代码，具体体现为方法的创建、调用等，业务代码的变动不需要改动这部分代码。因为起着调度、流程控制的作用，所以叫控制代码。 基于上面的分类，其实前面的讨论，都是对于控制代码而言的。 所谓的不稳定性，只存在于==控制代码==当中，对于==业务代码==，因为一定是不稳定的，所以讨论稳定性没有意义。 5. 依赖注入 到目前为止，已经消除了不稳定性，让代码符合了开闭原则。 不过，还完全没有运用IOC原理 对于依赖注入(Dependency Injection, DI)，我个人的理解是：依赖注入是IOC思想的一种体现方式。 5.1 实现依赖注入5.1.1 原来的依赖形式下面来看看普通的依赖形式，首先定义皮肤接口和皮肤类： 1public interface Skin &#123;2 void showSkin();3&#125;45public class MySkin implements Skin &#123;6 @Override7 public void showSkin() &#123;8 System.out.println(\"show my skin\");9 &#125;10&#125; 下面在英雄类中加入皮肤类依赖： 1public class Axe implements Hero &#123;2 public void showSkin() &#123;3 Skin skin = new MySkin(); // 加入依赖4 skin.showSkin();5 &#125;6&#125; 这样一来就实现了Hero和Skin的依赖关系，Hero依赖Skin，Hero只有拥有了皮肤，才能正常显示在玩家面前(没有额外皮肤的话，默认是初始皮肤)。 可以发现，这里的主导权在Hero手中，Hero需要主动生成Skin，或者在构造时设置Skin。 而由于new的出现，代码中就有了不稳定性。 直接的、正向的依赖关系会导致代码的不稳定性。 5.1.2 依赖注入上面的依赖关系会导致代码的不稳定性，这里用工厂模式来消除不稳定性。 首先在Hero接口中增加方法： 1public interface Hero &#123;2 void skill1();3 void skill2();4 void skill3();5 void skill4();6 void setSkin(Skin skin); // 增加设置skin的方法7 void showSkin(); // 增加展示皮肤的方法8&#125; 这里采用属性注入的方式。 然后在Hero中添加set方法和showSkin方法： 1public class Axe implements Hero &#123;2 Skin skin;34 public void setSkin(Skin skin) &#123;5 this.skin = skin;6 &#125;7 // 省略无关代码...89 @Override10 public void showSkin() &#123;11 skin.showSkin();12 &#125;13&#125; 接下来修改工厂类： 1// 上面的逻辑省略...2Hero hero = (Hero)HeroMeta.newInstance();3hero.setSkin(new MySkin()); // 注入skin 最后看主函数： 1Hero hero = HeroFactory.getHero();2hero.showSkin(); 可以看到，主函数中并没有主动调用set方法设置Hero类的依赖，而是由工厂代为设置了。 Hero依赖的内容，不再由Hero主动去索取，而是由工厂类注入，换句话说，工厂变成了主动方而Hero变成了被动方。 这样一来，控制权就从Hero手中，转移到了工厂类手中。 也就实现了==控制反转(Inversion of Control, IOC)==。 这种实现方式被称为==依赖注入==。 5.2 第三次理解不稳定性不难发现，在工厂中向Hero注入Skin的时候，使用了new关键字，这又导致了代码的不稳定。 在考虑如何消除不稳定性之前，可能先要考虑下面这个问题： 这段代码属于==控制代码==，还是==业务代码==？ 结合实际场景，一个英雄可能有多个皮肤，而使用哪一个皮肤是用户要决定的事情，所以，皮肤的不断切换、不断变化是==不可避免==的。 因为不稳定性不可避免，所以这段代码属于业务代码，那么这里的不稳定性就可以不用考虑。 5.3 类与容器的关系容器，也就是所谓的超级工厂，将像是独立于类之外的存在，它负责给类们装配、注入各种各样的依赖，从而使得类与类之间能够协同工作。（可以参考网上常用的齿轮图） 6. IOC6.1 在DI层面上再次抽象在第5节中，确实实现了Hero和工厂类之间控制权的反转。 不过，如果站在更高一层来看，所有的代码逻辑都是程序员来写，主动权牢牢控制在程序员手中，那么能不能将程序员手上的控制权，转移到其他角色，例如用户、产品经理手中呢？ 答案是肯定的。 6.1.1 转移程序员的控制权首先看工厂类的实现： 1Hero hero = (Hero)HeroMeta.newInstance();2hero.setSkin(new MySkin()); // 注入skin 虽然这里的不稳定性不可避免，但是每次需要更换皮肤是，还是需要程序员来更改逻辑。 要是由其他角色来告诉工厂该注入哪一个皮肤的话，那么控制权就从程序员手上释放掉了。 但是不可能要求其他角色(产品、用户)也会写代码。 那么有没有一种方式，使得不会写代码的人，也能修改逻辑呢？ 是有的。 6.1.2 连接其他角色与代码实际情况中，用户是通过UI界面来选择皮肤的，而且控制权确实是在用户手中，因为不可能每次用户更换皮肤时，程序员都去更改相应的逻辑，然后再重新上线游戏。 所以这里的UI就是连接用户和代码的桥梁，使得用户也可以控制程序的走向。 再比如，原来系统中使用的是MySql数据库，现在需要改成SqlServer数据库，那么就可以把数据库的配置信息放到配置文件中，例如： 1database = 'MySql' 这样一来，程序员就只需要关注SqlServer数据库操作的具体实现，而产品经理就可以负责“注入数据库”，也就是更改配置文件，比如改成： 1database = 'SqlServer' 虽然不能要求产品会写代码，但是改个配置文件还是可以的。 而且如果后续要是再改回MySql的话，只需要更改配置文件，项目代码完全不需要改动。 这样的话，就实现了==角色之间的控制反转==。 6.2 对IOC的浅见马丁老爷子说过，IOC是个非常抽象，非常模糊的概念，为了让人更好理解，老爷子才拿出了依赖注入这个例子，所以对于IOC的理解需要在日后的工作中慢慢体会，徐徐图之。 最后用一个例子结束本文。 一个项目就像是一个积木工厂，程序员是工厂中的员工，负责制造积木。 把积木拼装好之后用胶水死死粘上再卖出去，是非IOC。 把积木造出来之后直接卖出去，是IOC","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"原型模式","slug":"clone","date":"2020-04-25T05:53:13.000Z","updated":"2020-06-30T05:56:06.254Z","comments":true,"path":"2020/04/25/clone/","link":"","permalink":"kasimg.github.io/2020/04/25/clone/","excerpt":"你花费10天精力制作了一个精美的PPT，得到了领导的赞赏。 后来你又接到了做PPT的任务，你觉得上次那种风格很赞，想再次使用。 这个时候你会从头开始，再花个10天做出一个差不多的PPT吗？ 不，你不会。 你会把之前的PPT直接拷贝一份，在此基础之上加以修改，这样效率就得到极大提升。 这就是原型模式。","text":"你花费10天精力制作了一个精美的PPT，得到了领导的赞赏。 后来你又接到了做PPT的任务，你觉得上次那种风格很赞，想再次使用。 这个时候你会从头开始，再花个10天做出一个差不多的PPT吗？ 不，你不会。 你会把之前的PPT直接拷贝一份，在此基础之上加以修改，这样效率就得到极大提升。 这就是原型模式。 原型模式就像克隆，将原本一个创建步骤很复杂的对象直接拷贝一份来代替创建，提高效率。 下面看代码： 1public class PPT implements Cloneable &#123;23 // 这里省略了7天4 private String day1 = \"疯狂做PPT中...\";5 private String day2 = \"疯狂做PPT中...\";6 private String day3 = \"疯狂做PPT中...\";7 private Date deadline; // 存放日期对象8 private SimpleDateFormat sdf; // 日期格式化对象910 public PPT(Date deadline) &#123;11 this.deadline = deadline;12 sdf = new SimpleDateFormat(\"yyyy-MM-dd\");13 System.out.println(\"开始做PPT\");14 &#125;1516 @Override17 protected Object clone() throws CloneNotSupportedException &#123;18 return super.clone();19 &#125;2021 @Override22 public String toString() &#123;23 return \"PPT&#123;\" +24 \"day1='\" + day1 + '\\'' +25 \", day2='\" + day2 + '\\'' +26 \", day3='\" + day3 + '\\'' +27 '&#125;' + \"\\n\" + sdf.format(deadline) + \"，PPT终于做好了\";28 &#125;29&#125; 这里定义了一个PPT类，实现了==Cloneable==接口，只要实现了这个接口，这个类的实例对象就能调用克隆方法克隆自身。 下面测试： 1Date deadline = new Date(100, 1, 1);23PPT ppt1 = new PPT(deadline);4System.out.println(ppt1);5System.out.println(ppt1.hashCode());67System.out.println(\"################################\");89PPT ppt2 = (PPT) ppt1.clone();10System.out.println(ppt2);11System.out.println(ppt2.hashCode());1213// 打印信息14// 开始做PPT15// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;16// 2000-02-01，PPT终于做好了17// 122941651418// ################################19// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;20// 2000-02-01，PPT终于做好了21// 2016447921 首先看17和21行，发现hashcode并不相同，说明ppt1和ppt2是两个完全不同的对象。 然后看第14行，ppt1创建时调用了构造方法，而克隆ppt2时并没有调用，说明clone确实不是直接创建。 最后看第15和19行，发现内容确实相同，达到了克隆的效果。 乍一看，到这里克隆就已经结束了。不过这样的克隆是有问题的。 现在改变deadline的值： 1Date deadline = new Date(100, 1, 1);23PPT ppt1 = new PPT(deadline);4PPT ppt2 = (PPT) ppt1.clone();5System.out.println(ppt1);6System.out.println(\"\\n\");7System.out.println(ppt2);89System.out.println(\"################change deadline################\");1011// 改变deadline的值12deadline.setYear(101);13System.out.println(ppt1);14System.out.println(\"\\n\");15System.out.println(ppt2);1617// 打印信息18// 开始做PPT19// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;20// 2000-02-01，PPT终于做好了2122// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;23// 2000-02-01，PPT终于做好了24// ################change deadline################25// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;26// 2001-02-01，PPT终于做好了2728// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;29// 2001-02-01，PPT终于做好了 可以看到，更改日期之后，两个对象的deadline都从2000-02-01变成了2001-02-01。说明==两个对象共用一个date对象==。放到内存中看，就是两个PPT实例中的deadline指针指向同一个date对象。 此时，改变deadline对象会导致所有克隆出来的实例中的deadline对象发生改变，这有可能引发一系列问题。 假设用羊A克隆出了羊B，羊A和羊B需要共用一颗心脏，那么显然是不合理的。 所以这种不完全的克隆并不是真正的克隆，也称之为==浅克隆==。 下面实现依稀简单的“深克隆”： 1protected Object clone() throws CloneNotSupportedException &#123;2 PPT ppt = (PPT) super.clone();3 4 // 将date对象也克隆一次5 ppt.deadline = (Date) this.deadline.clone();6 return ppt;7&#125; 这里简单的将date对象也克隆了一次，打印结果如下： 1// 开始做PPT2// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;3// 2000-02-01，PPT终于做好了45// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;6// 2000-02-01，PPT终于做好了7// ################change deadline################8// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;9// 2001-02-01，PPT终于做好了1011// PPT&#123;day1='疯狂做PPT中...', day2='疯狂做PPT中...', day3='疯狂做PPT中...'&#125;12// 2000-02-01，PPT终于做好了 可以看到改变之前两者日期相同，而改变deadline之后，ppt1的deadline变成了2001，而ppt2的deadline则没有改变，说明深克隆成功实现。 当然这里的所谓深克隆也并非真正的深克隆，因为如果date对象中还有引用类型的话，那么问题依然存在。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"kasimg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"适配器模式","slug":"adapter","date":"2020-04-19T05:50:17.000Z","updated":"2020-06-30T05:52:09.301Z","comments":true,"path":"2020/04/19/adapter/","link":"","permalink":"kasimg.github.io/2020/04/19/adapter/","excerpt":"你买了一台新笔记本电脑，兴奋地拆开包装，连上电源，插上网线…等等？为什么没有网线接口？？ 你无奈地看着轻薄的机身和type-c接口，陷入了沉思。 你是个游戏玩家，更喜欢网线直连带来的稳定急速游戏体验，于是你决定买一个适配器。 通过适配器串联type-c接口和网线，这就是适配器模式。","text":"你买了一台新笔记本电脑，兴奋地拆开包装，连上电源，插上网线…等等？为什么没有网线接口？？ 你无奈地看着轻薄的机身和type-c接口，陷入了沉思。 你是个游戏玩家，更喜欢网线直连带来的稳定急速游戏体验，于是你决定买一个适配器。 通过适配器串联type-c接口和网线，这就是适配器模式。 1. 类适配器下面看代码，首先定义一个网线类，用来连接网络。 1public class Cable &#123;2 public void request() &#123;3 System.out.println(\"连接网线上网\");4 &#125;5&#125; 接着定义转换器接口，这个接口只有一个方法，就是适配。 1public interface Adapter &#123;2 void adapt(); // 适配方法3&#125; 随后定义一个实现接口的具体适配器，这里是typec适配器。 1public class TypecAdapter extends Cable implements Adapter &#123;2 @Override3 public void adapt() &#123;4 super.request();5 &#125;6&#125; 注意到此处的TypecAdapter不仅实现了适配器接口，还继承了网线类Cable，这样一来，适配器类就可以使用父类网线类的方法，这种适配模式也被称作为==类适配器模式==。 现在是时候拿出电脑来了： 1public class Computer &#123;2 // 需要转接头才能上网3 public void onlineSurfing(TypecAdapter typecAdapter) &#123;4 typecAdapter.adapt();5 &#125;6&#125; 这里的Computer类实现了一个上网的方法，接受一个转接头作为参数，通过转接头的适配方法，打通电脑和网线之间的通道。 最后测试： 1Computer computer = new Computer();2computer.onlineSurfing(new TypecAdapter());34// 打印信息5// 连接网线上网 成功上网。 不过这种适配模式有几个问题： 如果需要继承的类发生改变，那么需要直接改动代码，不符合开闭原则，灵活性降低。 java具有单继承性，这种模式下，每种适配器只能继承一个类，如果需要适配的对象超过两个，那么就不能用这种方式实现。 测试样例中根本没有出现Cable类，只有TypecAdapter类，Cable类被集成到了TypecAdapter类中，作用以及角色被淡化，导致代码的表现力不佳。 2. 对象适配器为了解决上述的问题，现在对于TypecAdapter作修改： 1public class TypecAdapter implements Adapter &#123;2 // 将cable作为可以插拔的接口3 private Cable cable;45 // 相当于在适配器接口中插入相应的网线6 public void setCable(Cable cable) &#123;7 this.cable = cable;8 &#125;910 @Override11 public void adapt() &#123;12 cable.request();13 &#125;14&#125; 首先，这里将cable作为属性保存在适配器类中，相当于在适配器上创建了一个可以插网线的接口。 其次，实现了setCable方法，接受一个Cable类型的参数，调用这个方法相当于向插槽中插入了网线。 下面测试： 1Computer computer = new Computer();23// 加入对cable的显示定义4Cable cable = new Cable();56// 创建适配器并且将网线插入插槽7TypecAdapter typecAdapter = new TypecAdapter();8typecAdapter.setCable(cable);910computer.onlineSurfing(typecAdapter);1112// 打印信息13// 连接网线上网 这里解决了上述的三个问题： 如果接口发生改变，只需要在原有基础上，向TypecAdapter类中加入新的“插槽”即可，不需要改变原来的代码 同理，如果有多个对象需要适配，那么直接增加即可 setCable(cable)显示调用，表明将网线插入插槽，代码表现力和可读性增强。 3. 总结 适配器模式将原本由于接口不兼容而无法协同的类可以在一起工作。 适配器模式有以下几种角色： 目标接口。也是用户期望的接口，就是这里的typec接口。 适配对象。需要被适配的接口，就是这里的网线接口。 适配器。适配1和2的装置，就是这里的typec适配器。 适用场景： 系统中有些老的类，接口或者方法名已经不符合现有要求。 将彼此关联性小的一些类通过适配器获得协同工作的能力。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"kasimg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"桥接模式","slug":"bridge","date":"2020-04-18T05:00:11.000Z","updated":"2020-06-30T05:11:50.297Z","comments":true,"path":"2020/04/18/bridge/","link":"","permalink":"kasimg.github.io/2020/04/18/bridge/","excerpt":"你想整理一份当前市面上主流的电脑产品信息，于是画了下面一张图： 图1. 电脑信息1 乍一看，清晰明了，层次分明，可是仔细一琢磨，还是有些问题： 如果要新增一种电脑类型，比如手表电脑，那么就要在手表电脑下面再增加每种品牌的电脑个一种。 同理，如果要增加一种品牌，那么原有电脑类型下面也全都需要更新 这两个问题导致扩展非常麻烦，且扩展之后结构会越来越臃肿和复杂。","text":"你想整理一份当前市面上主流的电脑产品信息，于是画了下面一张图： 图1. 电脑信息1 乍一看，清晰明了，层次分明，可是仔细一琢磨，还是有些问题： 如果要新增一种电脑类型，比如手表电脑，那么就要在手表电脑下面再增加每种品牌的电脑个一种。 同理，如果要增加一种品牌，那么原有电脑类型下面也全都需要更新 这两个问题导致扩展非常麻烦，且扩展之后结构会越来越臃肿和复杂。 于是你转换了一下思路，又重新画了一张图： 图2. 电脑信息2 图2中横向虚线表示电脑种类，纵向虚线表示品牌，纵横交汇处的店表示某一中具体的电脑。 可以看到，如果需要添加电脑种类，只需要加一条横向虚线就会产生n个交汇点（n为品牌数），同理，增加品牌只需要增加纵向虚线即可。 这样一来就大大提升了可扩展性。 第二种图的思想就是==桥接模式==。 1. 单一职责原则在面向对象中，图1违背了==单一职责原则==。所谓单一职责原则，就是每个类只负责一项功能。 图1的第三层中，如果把“联想台式”看做一个类，那么这个类代表了2个功能：品牌和类型。 而反观图2把每一条虚线看做一个类，每个类只关注一个问题、实现一个功能，所以图2的可扩展性比图1要好。 2. 实现图2中的逻辑下面看代码，首先定义品牌接口： 1public interface Brand &#123;2 String brandInfo();3&#125; 品牌类中只定义了一个方法，目的是返回品牌名称的字符串。 接着定义具体的品牌类： 1public class Lenovo implements Brand &#123;2 @Override3 public String brandInfo() &#123;4 return \"联想牌\";5 &#125;6&#125;7// 其他省略... 然后定义类型接口和类型实现类： 1// 类型接口2public interface Type &#123;3 String typeInfo();4&#125;56// 实现类7class PC implements Type &#123;8 @Override9 public String typeInfo() &#123;10 return \"台式\";11 &#125;12&#125;1314// 其余省略... 接下来定义电脑类： 1public class Computer &#123;2 Brand brand;3 Type type;45 public Computer(Brand brand, Type type) &#123;6 this.brand = brand;7 this.type = type;8 &#125;910 public void computerInfo() &#123;11 System.out.println(brand.brandInfo() + type.typeInfo());12 &#125;1314&#125; 电脑类有两个属性，品牌和类型（可以看做在图2中横纵各取一条虚线），构造函数给两个属性赋值，还有一个用于打印信息的函数。 最后来测试： 1// 用品牌和类型创建一个电脑实例2Computer computer = new Computer(new Lenovo(), new PC());34// 打印电脑信息: 联想牌台式5computer.computerInfo(); 这里用品牌和类型创建了一个电脑实例，相当于在图2中两条虚线交汇形成了一个点。 到此为止，图2中表现的内容就用代码比较好地实现了出来。 3. 改进如果只是想表达图2的意思的话，到上一步就可以了，不过如果仔细思考，就会发现此时还有一个问题： 在实际情况下，不同类型的电脑具体实现逻辑大概率不同，如果只实现了一个Computer类，那么很难对这些进行区分。 比如平板需要实现触摸功能，而台式机几乎不需要触屏功能；再比如，ios和android平板和主流笔记本以及台式机的操作系统不一样，所以这方面也应该区别对待。 于是考虑将computer作为父类，将具体型号的电脑作为子类来实现各自的功能。 下面看代码，品牌接口和实现类不变，首先改变Computer类： 1public abstract class Computer &#123;2 // 品牌3 Brand brand;45 public Computer(Brand brand) &#123;6 this.brand = brand;7 &#125;89 // 抽象方法，具体实现由子类完成10 abstract public void computerInfo();1112&#125; 和之前不同的是，这里的电脑类变成了抽象类，保留了品牌信息，定义了一个抽象方法，其具体实现由子类完成。 然后定义子类： 1class PC extends Computer &#123;23 public PC(Brand brand) &#123;4 super(brand);5 &#125;67 @Override8 public void computerInfo() &#123;9 // 省略大量关于PC的操作10 System.out.println(brand.brandInfo() + \"台式\");11 &#125;12&#125;13// 其余省略... 可以看到，在子类中重写了computerInfo方法，这里就可以加入各种PC独有的逻辑。 下面测试： 1// 创建电脑实例2Computer computer = new PC(new Lenovo());34// 打印信息: 联想牌台式5computer.computerInfo(); 和前面不一样的是，这里用子类来实例化对象，再用多态存放实例。 到此为止，不仅图2的思想得到了实现，也更符合实际情况。 4. 总结优点： 减少子类个数，降低维护成本。比如图1中，有3个一级子类，9个二级子类，而图2中只有6个。再抽象一点，图1中类的空间复杂度为O(m~1~ m~2~ … * m~k~)，图2的空间复杂度为O(m~1~ + m~2~ + … + m~k~)，其中k为维度（在这里就是品牌和电脑种类），m~k~为维度的长度（比如品牌有3种）。如果维度很多的话，桥接模式能够极大减少类的数量。 增强可扩展性。 缺点： 增加系统的理解与设计难度。 需要系统能够分离出一系列正交的维度（个个维度之间互不相关），对于强耦合的维度不使用。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"kasimg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"代理模式","slug":"agency","date":"2020-04-12T04:54:24.000Z","updated":"2020-06-30T04:59:25.054Z","comments":true,"path":"2020/04/12/agency/","link":"","permalink":"kasimg.github.io/2020/04/12/agency/","excerpt":"你要结婚了，有一大堆事情要做，请帖、喜糖、策划、预定饭店、预定车…如果全部由你来做的话，你一定会焦头烂额。当然你大可不必如此，只需要专注于如何盛装出席婚礼这件事，其他的事情全部交给婚庆公司去做，这样你就会轻松许多。 这里的婚庆公司就是代理，这种把不必要的事情委派给其他角色去做，自己只专注于核心业务的模式，就叫代理模式。","text":"你要结婚了，有一大堆事情要做，请帖、喜糖、策划、预定饭店、预定车…如果全部由你来做的话，你一定会焦头烂额。当然你大可不必如此，只需要专注于如何盛装出席婚礼这件事，其他的事情全部交给婚庆公司去做，这样你就会轻松许多。 这里的婚庆公司就是代理，这种把不必要的事情委派给其他角色去做，自己只专注于核心业务的模式，就叫代理模式。 1. 静态代理 将公共操作提取出来放在代理对象中，独一无二的逻辑放在真实对象中实现 你和朋友正在打羽毛球比赛，每次打完一个球，你都需要跑到记分牌前更新比分信息，一局如果 20 个球，那么你就得跑 20 趟。 而如果你们找另外一个人专门更新比分信息，那么你们就省了许多事，只需要专心打球就行。 这里的第三个人就相当于代理，它完成了许多重复性的工作，让你们可以专注于核心的事情。 方便在原有的逻辑上增加一些公用的逻辑。而改动原有的业务代码，是大忌 拔河比赛如火如荼的进行着，因为顶着烈日，队员们缺水严重，急需补水。如果让队员们腾出一只手来喝水的话，非常可能就输掉了比赛。 而如果这时候找来一个另外的人，专门负责给队员们送水喝，那么队员们仍然可以专注于比赛，而且也解决了缺水的问题。 这个人就是代理，他相当于给所有的队员增加了一个喝水的功能，而队员不需要做任何的改变。 好处： 使真实角色的操作更加纯粹，减少耦合性 公共业务交给了代理角色，实现了业务分工 公共业务发生扩展的时候，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量翻倍 2. 动态代理1// 首先写一个代理需要用到的接口2public interface Navigate &#123;3 void navigate();4&#125;56// 然后定义一个实现接口的类7public class Navigator implements Navigate &#123;8 @Override9 public void navigate() &#123;10 System.out.println(\"高圆圆竭诚为您播报\");11 &#125;12&#125; 因为动态代理时会产生一个代理对象，这个对象需要通过接口去访问原来类中定义的方法实现。 接下来按照官方文档，定义一个用来生成代理对象的类： 1public class MyProxy implements InvocationHandler &#123;23 // 被代理的对象4 private Object target;56 public void setTarget(Object target) &#123;7 this.target = target;8 &#125;910 // 动态获取代理类的方法11 public Object getProxy() &#123;12 return Proxy.newProxyInstance(this.getClass().getClassLoader(),13 target.getClass().getInterfaces(), this);14 &#125;1516 // 代理对象在调用被代理对象中的同名方法时，其实是调用了这个方法17 // 并通过反射的形式调用被代理对象中的同名方法18 @Override19 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;20 System.out.println(\"I am invoked\");21 Object result = method.invoke(target, args);22 return null;23 &#125;24&#125; 测试效果： 1// 创建被代理对象的实例2Navigate nav = new Navigator();34// 创建生成代理对象的对象实例5MyProxy myProxy = new MyProxy();67// 先设置要代理的对象8myProxy.setTarget(nav);910// 再生成代理类, 使用多态11Navigate proxy = (Navigate) myProxy.getProxy();1213// 这里会先打印\"I am invoked\" 再打印出 \"高圆圆竭诚为您播报\"14proxy.navigate(); 生成代理类的时候： 1return Proxy.newProxyInstance(this.getClass().getClassLoader(),2 target.getClass().getInterfaces(), this); 传入了 target.getClass().getInterfaces()参数，也就是被代理类的接口信息，代理类获取这个接口之后自己也实现了这个接口，所以代理类能够调用 navigate 方法。 传入了 this 参数，说明当前生成 proxy 类的类实例信息被代理类获取，其中的 invoke 自然也在其中。 1public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;2 System.out.println(\"I am invoked\");3 Object result = method.invoke(target, args);4 return null;5&#125; 这里传入了 method 参数，当代理类调用接口中的方法时，这个方法的信息就被获取并传入到 invoke 方法中，于是在 invoke 方法中就可以通过反射的方式来调用被代理对象实例中的方法。这里试验了一下调用方法时获取接口的方法对象： 1// 通过当前的调用栈信息获取当前调用的方法名2// [1]表示当前的执行堆栈3String methodName = Thread.currentThread().getStackTrace()[1].getMethodName();45// 获取当前实例的接口对象，可能有多个6Class&lt;?&gt;[] interfaces = this.getClass().getInterfaces();78// 通过接口对象获以及方法名获取方法信息9// 这里因为只有一个接口所以直接用[0]访问，如果有多个的话可能需要遍历搜索10System.out.println(interfaces[0].getDeclaredMethod(methodName)); 在调用原本方法之余，invoke 方法中可以加上任何公用的方法，从而实现代理模式。 动态代理省去了代理类中对于接口方法的具体实现，而是通过传入的接口参数去实现","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"kasimg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"建造者模式","slug":"builder","date":"2020-04-11T04:48:05.000Z","updated":"2020-06-30T04:52:47.044Z","comments":true,"path":"2020/04/11/builder/","link":"","permalink":"kasimg.github.io/2020/04/11/builder/","excerpt":"你想造一幢房子。 工厂模式是： 有很多施工队，每个施工队只能造某一种房子，你想要什么房子，就找对应的施工队。 每个施工队的建造流程都可能不相同。 建造者模式是： 有一个实力强劲的施工队，其中有一个包工头，包工头手下有各种掌握不同技能的工人。 这个包工头掌握了一套流程，ABCD四步造出一个房子。 通过让不同的工人来做每一步，就可以造出各种各样的房子。 你只需要告诉这个包工头你需要造哪种房子即可。","text":"你想造一幢房子。 工厂模式是： 有很多施工队，每个施工队只能造某一种房子，你想要什么房子，就找对应的施工队。 每个施工队的建造流程都可能不相同。 建造者模式是： 有一个实力强劲的施工队，其中有一个包工头，包工头手下有各种掌握不同技能的工人。 这个包工头掌握了一套流程，ABCD四步造出一个房子。 通过让不同的工人来做每一步，就可以造出各种各样的房子。 你只需要告诉这个包工头你需要造哪种房子即可。 1. 包工头纵览全局下面来看代码，首先定义一个抽象类： 1public abstract class Builder &#123;2 abstract void firstStep();34 abstract void secondStep();56 abstract void thirdStep();78 abstract void forthStep();910 abstract Building getBuilding();11&#125; 这个抽象类中定义了四个步骤，代表建造房子的一套流程；另外还有一个getBuilding方法，用于获取建造好的房子。 设计好了流程，下面需要工人来干活了： 1public class Worker extends Builder &#123;23 Building building;45 public Worker() &#123;6 building = new Building();7 &#125;89 @Override10 Building getBuilding() &#123;11 return building;12 &#125;1314 @Override15 void firstStep() &#123;16 System.out.println(\"打地基\");17 &#125;1819 @Override20 void secondStep() &#123;21 System.out.println(\"钢筋工程\");22 &#125;2324 @Override25 void thirdStep() &#123;26 System.out.println(\"铺电线\");27 &#125;2829 @Override30 void forthStep() &#123;31 System.out.println(\"粉刷\");32 &#125;33&#125; Worker类里具体实现了四个步骤。 工人有了，现在需要包工头来指挥： 1public class Director &#123;2 public Building build(Worker worker) &#123;3 worker.firstStep();4 worker.secondStep();5 worker.thirdStep();6 worker.forthStep();78 return worker.getBuilding();9 &#125;10&#125; 包工头类中定义了一个方法build，接受一个worker作为参数，相当于要来指挥这个worker干活。 这里有两个关键点： 可以传入不同的worker，不同的worker对于某个步骤的具体实现可以完全不同。甚至可以传入多个worker，来搭配完成各种各样的需求 步骤可以打乱顺序，包工头可以使用任意的顺序来组合流程 最后来测试一下： 1Director director = new Director();2director.build(new Worker());34// 打印信息5打地基6钢筋工程7铺电线8粉刷 2. 用户人为干预上述建造房子过程中，用户并不知道房子的具体建造流程。** ==有些时候，用户希望自己能够控制流程==，来精确实现自己的需求，这个时候，用户自己就成了director。 现在你进入了一家KFC。 你想要自己定制一份专属套餐，于是你向服务员说出了你想要的食物1234… 这里的服务员可以看做worker，最终的套餐可以看做房子，而你，正是director。 下面看代码，首先创建一个Builder抽象类： 1public abstract class Builder &#123;2 // 一个套餐包含四个部分3 abstract Builder orderA(String food);45 abstract Builder orderB(String food);67 abstract Builder orderC(String food);89 abstract Builder orderD(String food);1011 abstract SetMenu getSetMenu();12&#125; 其中实现了4个方法，分别对应点套餐的4个部分。另外还有获取最终套餐的方法。 下面定义套餐类： 1public class SetMenu &#123;2 // 默认套餐3 private String foodA = \"香辣鸡腿堡\";4 private String foodB = \"中杯可乐\";5 private String foodC = \"新奥尔良烤翅\";6 private String foodD = \"上校鸡块\";78 // 将套餐的A部分换成自定义食物9 public void setFoodA(String food) &#123;10 this.foodA = food;11 &#125;1213 public void setFoodB(String food) &#123;14 this.foodB = food;15 &#125;1617 public void setFoodC(String food) &#123;18 this.foodC = food;19 &#125;2021 public void setFoodD(String food) &#123;22 this.foodD = food;23 &#125;2425 // 用于展示菜单26 @Override27 public String toString() &#123;28 return \"SetMenu&#123;\" +29 \"foodA='\" + foodA + '\\'' +30 \", foodB='\" + foodB + '\\'' +31 \", foodC='\" + foodC + '\\'' +32 \", foodD='\" + foodD + '\\'' +33 '&#125;';34 &#125;35&#125; 这里首先定义了一组默认食物，如果用户不希望自定义套餐，那么就会提供默认套餐。 菜单类中还有4个方法，用来自定义套餐的各个部分。 下面有请服务员出场： 1public class Waitor extends Builder &#123;23 private SetMenu setMenu;45 public Waitor() &#123;6 setMenu = new SetMenu();7 &#125;89 @Override10 Builder orderA(String food) &#123;11 setMenu.setFoodA(food);12 // 这里返回本身，为了方便连续点餐13 return this;14 &#125;1516 @Override17 Builder orderB(String food) &#123;18 setMenu.setFoodB(food);19 return this;20 &#125;2122 @Override23 Builder orderC(String food) &#123;24 setMenu.setFoodC(food);25 return this;26 &#125;2728 @Override29 Builder orderD(String food) &#123;30 setMenu.setFoodD(food);31 return this;32 &#125;3334 @Override35 SetMenu getSetMenu() &#123;36 return setMenu;37 &#125;38&#125; 服务员类继承了建造者类，其中实现了4个方法，用来接收用户的需求，并改变菜单中的食物种类。 这里每次点餐之后都返回了实例本身，这样一来就可以==链式调用==，方便了用户连续点餐。 最后让我们请出包工头..不对，现在已经不需要包工头了，用户自己就是包工头： 1// 招呼服务员过来点餐2Waitor waitor = new Waitor();34// 先来个默认套餐5SetMenu setMenu = waitor.getSetMenu();67// 看看套餐的内容8System.out.println(setMenu);910// 打印信息11// SetMenu&#123;foodA='香辣鸡腿堡', foodB='中杯可乐', foodC='新奥尔良烤翅', foodD='上校鸡块'&#125; 可以看到，这里并没有director对象，那么如果需要改变套餐内容，就要想下面这样做： 1// 更喜欢吃鱼 不想喝可乐2waitor.orderA(\"芝士鳕鱼鸡腿堡\").orderB(\"大杯雪碧\");34System.out.println(setMenu);5// SetMenu&#123;foodA='芝士鳕鱼鸡腿堡', foodB='大杯雪碧', foodC='新奥尔良烤翅', foodD='上校鸡块'&#125; 虽然没有director，但还是完成了菜单的变更。 只要对服务员说出你想吃的食物就行，套餐的所有内容都由用户决定，用户就是director。 这里也暗含了==控制反转 ==的思想。 3. 总结优点： 对象的建造和使用分离，实现解耦，客户端不需要知道产品的内部组成和实现细节 产品创建步骤由不同的方法实现，过程清晰明了 建造者类相互独立，有利于系统扩展 缺点： 创建的产品需要有较多的共同点，才能抽象出通用的建造流程。不适用产品间差异大的场景 如果产品足够复杂，那么会导致代码量巨大，系统变得臃肿","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"kasimg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"工厂模式","slug":"factory","date":"2020-04-05T03:57:39.000Z","updated":"2020-06-30T04:05:11.900Z","comments":true,"path":"2020/04/05/factory/","link":"","permalink":"kasimg.github.io/2020/04/05/factory/","excerpt":"制造汽车有汽车工厂。 制造船有船工厂。 制造对象当然也有对象工厂。","text":"制造汽车有汽车工厂。 制造船有船工厂。 制造对象当然也有对象工厂。 1. 静态工厂（简单工厂） 你想出国旅游，可是你只会讲中文。 你可以从头开始学习一门语言，直到能使用这门语言正常交流，再出国。 那么如果你想去的国家不止一个，而且这些国家都说不同的语言呢？每次出国前都需要学一门新语言，成本实在太高。 你大可以买一台翻译机。你要做的只是对着它说出中文，它就会返回给你各种各样的语言。极大降低了你打成目标的成本。 这里的翻译机就相当于一个工厂，你只需要告诉工厂，到底把你说的话翻译成哪国语言，它就会把翻译后的语言返回给你。 你根本不需要关心它是如何翻译的。 这就是静态工厂模式。 和代理模式类似，都是使用第三个对象来简化操作，区别在于前者是用来包装某些方法，后者是用来创建对象 使用者不关心具体的类的创建过程，比如有大量的参数需要传递，那么工厂模式就可以大大简化创建过程 增加新产品时必须更改原来的代码，不符合开闭原则 下面看代码： 1public class Translator &#123;2 String language;34 public Translator(String language) &#123;5 this.language = language;6 &#125;78 public void translate() &#123;9 System.out.println(\"将中文翻译成: \" + language);10 &#125;11 12 // ...省略各种参数和配置13&#125; 首先定义了一个Translator类代表翻译机。翻译机的属性language表示它可以翻译的语言类型，方法translate用来打印信息。 然后定义一个工厂类： 1public class TranslatorFactory &#123;2 private static Translator translator;34 public static Translator getTranslator(String language) &#123;5 if (language == \"英语\") &#123;6 translator = new Translator(\"English\");7 // ...省略一大堆配置8 &#125; else if (language == \"日语\") &#123;9 translator = new Translator(\"Japanese\");10 // ... 同样省略一大堆配置11 &#125;12 return translator;13 &#125;14&#125; 工厂类提供一个静态的getTranslator方法，返回一个Translator实例。 这了使用了if判断条件来创建实例，而没有使用下面这种方式： 1translator = new Translator(language); 因为要配置一个翻译机，并不是简简单单给一个语言的名字就行，而是需要大量的配置(这里省略…)。 这里的翻译机相当于只实现了两种语言的翻译。 接下来在测试类中测试： 1// 通过工厂类的静态方法获取相应的翻译机实例对象2Translator englishTranslator = TranslatorFactory.getTranslator(\"英语\");34// 打印信息5englishTranslator.trans(); 可以看到，在上面的例子当中，用户需要知道的之后“英语”两个字，就能获取一个翻译机，并不需要知道翻译机内部是如何配置的。 这就实现了使用者和创建者之间的耦合关系，使用者不需要关心实例如何创建，只需要专注于使用即可。 2. 工厂方法模式 上面的静态工厂模式有一个问题，就是一台翻译机能够翻译的语言是有限的。 万一需要翻译一门新的语言，就需要更改其内部结构，使它能支持新的语言，这很麻烦。 所以你需要新买一台新的、能支持新语言的翻译机。 每台翻译机支持特定的语言，需要翻译哪些语言就买对应的翻译机，这就是工厂方法模式。 这个模式又会带来新的问题，那就是会大大增加你的开销。 比如现在不仅需要翻译机能翻译英语和日语，还需要它翻译阿拉伯语，如果用上面的静态工厂模式，就需要在TranslatorFactory内部做改动，加上对阿拉伯语的配置逻辑，这就不符合开闭原则。 那么就有了工厂方法模式，就是为每一种翻译机配备一个工厂类。相当于如果需要翻译新的语言，那么就得新买一台翻译机。 下面来看下代码，首先定义一个工厂类接口： 1public interface TranslatorFactory &#123;2 // 工厂类需要能生产翻译机对象3 Translator getTranslator();4&#125; 接着定义一个专门生产英语翻译机的工厂类： 1public class EnglishTranslatorFactory implements TranslatorFactory &#123;2 @Override3 public Translator getTranslator() &#123;4 // ...省略大量配置5 return new Translator(\"english\");6 &#125;7&#125; 那么，我们需要英语翻译机时，就直接找EnglishTranslatorFactory工厂去生产即可： 1Translator translator = new EnglishTranslatorFactory().getTranslator();2translator.translate(); // 打印 “将中文翻译成: english” 这样的好处是，当我们有新语言翻译需求时，不需要改变原来的代码，只需要增加一个工厂类即可： 1public class ArabicTranslatorFactory implements TranslatorFactory &#123;2 @Override3 public Translator getTranslator() &#123;4 return new Translator(\"Arabic\");5 &#125;6&#125; 如此操作的好处是遵循了开闭原则，提高程序的可扩展性。而缺点则是对于每一种语言就需要有一个对应的工厂类，增加了代码量。 3. 抽象工厂模式 你需要买手机。 去数码城找中间商选你喜欢的牌子买，这叫简单工厂模式。 喜欢什么牌子，去对应的专卖店买，这叫工厂方法模式。 图1 简单工厂模式和工厂方法模式 上面的两种模式都是针对单一产品而言的，如果有多种产品呢？考虑到可扩展性，这里采用工厂方法模式进行扩展。 可以在工厂方法模式的基础上加别的产品的接口 比如这样： 1public class HuaweiFactory implements PhoneProductor, RouterProductor, PadProductor... 可以看到，如果产品种类不多的话，直接扩展还可以接受，但是如果产品很多的话，这样写就显得非常的不美观、不简洁、不优雅。 使用更优雅的写法。 于是就想到，可不可以只实现一个接口，在这个接口中定义所有的生产产品的方法呢？ 当然可以，这就是==抽象工厂模式==。 首先，定义一个抽象工厂类： 1public interface AbstractProductFactory &#123;2 // 生产手机3 Phone productPhone();45 // 生产路由器6 Router productRouter();7&#125; 这个抽象工厂目前有两个功能，生产手机和生产路由器。 接下来定义手机和路由器两个产品： 1public interface Phone &#123;2 void start();34 void shutDown();56 void dial();78 void text();9&#125;1011public interface Router &#123;12 void start();1314 void shutDown();1516 void setting();17&#125; 然后定义4个产品实现类，分别是小米手机、小米路由器、华为手机、华为路由器： 1public class XiaomiPhone implements Phone &#123;2 @Override3 public void start() &#123;4 System.out.println(\"开启小米手机\");5 &#125;67 @Override8 public void shutDown() &#123;9 System.out.println(\"关闭小米手机\");10 &#125;1112 @Override13 public void dial() &#123;14 System.out.println(\"使用小米手机拨号\");15 &#125;1617 @Override18 public void text() &#123;19 System.out.println(\"使用小米手机发短信\");20 &#125;21&#125;22// 其余的代码省略... 接下来要定义两个抽象工厂的实现类：小米工厂和华为工厂： 1public class XiaomiFactory implements AbstractProductFactory &#123;2 @Override3 public Phone productPhone() &#123;4 return new XiaomiPhone();5 &#125;67 @Override8 public Router productRouter() &#123;9 return new XiaomiRouter();10 &#125;11&#125;12// 华为工厂省略... 这样一来，每个工厂类只需要实现一个接口即可。 后续添加产品也非常方便，只需要加上产品接口，然后在抽象工厂类AbstractProductFactory中添加接口即可，工厂类完全不需要改动。 总结一下三种工厂模式 模式名称 优点 缺点 适用场景 简单工厂模式 简单，代码量少 可扩展性低 产品较少，无扩展需求 工厂方法模式 可扩展性较高 代码量较多 产品较少，有扩展需求 抽象工厂模式 可扩展性高 代码量多 产品较多，有扩展需求 最后说一句：没有最好的模式，只有最适合的模式。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"kasimg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"单例模式","slug":"singleton","date":"2020-04-04T03:50:43.000Z","updated":"2020-06-30T03:57:44.060Z","comments":true,"path":"2020/04/04/singleton/","link":"","permalink":"kasimg.github.io/2020/04/04/singleton/","excerpt":"你每天放学回家之后，都会把所有的课本全都扔掉，然后再全部买一本新的。 你为了买书省吃俭用，很快，你每天的午餐从二荤三素变成了一个馒头。 因为你每天都用新书，之前在书上记的笔记全都丢失了，完全没法复习，除非你每天都把之前的笔记全都抄一遍。 你图啥呢？ 所以更加合理的做法是，一学期只用一本书，这本书保留你做的所有笔记。 一学期用一本书就是单例模式。 单例模式主要用来节省资源，以及保留一些全局的信息。","text":"你每天放学回家之后，都会把所有的课本全都扔掉，然后再全部买一本新的。 你为了买书省吃俭用，很快，你每天的午餐从二荤三素变成了一个馒头。 因为你每天都用新书，之前在书上记的笔记全都丢失了，完全没法复习，除非你每天都把之前的笔记全都抄一遍。 你图啥呢？ 所以更加合理的做法是，一学期只用一本书，这本书保留你做的所有笔记。 一学期用一本书就是单例模式。 单例模式主要用来节省资源，以及保留一些全局的信息。 1. 饿汉式 今天第八节是语文课。 你在上第一节课的时候，就把语文课本摊开放在桌上，为了语文课做准备。 事先摊开课本会导致你其他科目的课本没有足够的地方放，降低了学习效率。 对应到代码： 1class HungryMan &#123;2 // 私有化构造函数，使得无法用new构造实例3 private HungryMan() &#123;&#125;45 // 创建静态不可变的对象实例6 private final static HungryMan HUNGRY_MAN = new HungryMan();78 // 静态公共方法获取单例对象9 public static HungryMan getInstance() &#123;10 return HUNGRY_MAN;11 &#125;12&#125; 可以看到这里事先创建了一个实例对象，用户只能使用类的getInstance方法获取这个实例，而且每次获取的都是同一个实例。 这就简单地完成了单例模式。 不过这种做法有个缺点，就像上面的例子中说的，实例对象在获取实例之前被创建，在调用getInstance之前白白占用了资源。 2. 懒汉式 你只有在上课之前才会把相应科目的课本摊开放在桌上。 为了解决饿汉式单例模式所暴露出的问题，新的单例模式”懒汉式”出现了。代码如下： 1class LazyMan &#123;2 private LazyMan() &#123;&#125;34 // 因为要在使用时才创建，需要重新赋值，所以不能用final5 private static LazyMan LAZY_MAN;67 public static LazyMan getInstance() &#123;8 // 如果之前没有创建过，那么就创建一个新的实例然后返回9 // 否则直接返回10 if (LAZY_MAN == null) &#123;11 LAZY_MAN = new LazyMan();12 &#125;13 return LAZY_MAN;14 &#125;15&#125; 可以看到，懒汉式和饿汉式的区别就在于前者只有在需要的时候才创建，而后者无论需不需要都事先创建。 前者能解决资源占用问题，不过也带来了一个新的问题：==线程不安全== 首先创建一些进程： 1for (int i = 0; i &lt; 10; i++) &#123;2 new Thread(() -&gt; &#123;3 LazyMan.getInstance();4 &#125;).start();5&#125; 然后加上一些打印信息： 1private LazyMan() &#123;2 System.out.println(Thread.currentThread().getName() + \" init instance\");3&#125; 运行程序，打印信息如下： 1Thread-6 init instance2Thread-5 init instance3Thread-0 init instance4Thread-7 init instance5Thread-2 init instance6Thread-1 init instance7Thread-3 init instance8Thread-4 init instance 可以看到，有超过一个线程进入了构造方法，说明有多个实例被创建，这就使得单例模式变得毫无意义。 于是把获取实例的方法改成同步方法： 1public synchronized static LazyMan getInstance() &#123;2 if (LAZY_MAN == null) &#123;3 LAZY_MAN = new LazyMan();4 &#125;5 return LAZY_MAN;6&#125; 这样的话，才完成了一个线程安全的单例模式。 不过问题还没有结束，虽然线程安全了，但是==反射==机制仍然能破坏单例模式： 1// 正常获取实例2LazyMan instance = LazyMan.getInstance();34// 通过反射获取无参构造器信息5Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(null);67// 获取通行证，接下来可以越过任何私有访问限制8declaredConstructor.setAccessible(true);910// 通过反射创建一个新的实例11LazyMan instance2 = declaredConstructor.newInstance();1213// 打印一下两个实例的信息14System.out.println(instance);15System.out.println(instance2); 打印信息如下： 1com.kasim.designPattern.LazyMan@61bbe9ba2com.kasim.designPattern.LazyMan@610455d6 可以看到，两个实例的内存地址不一样，说明是两个不同的实例，所以，==反射破坏了单例模式== 为了防止反射从中作梗，我们需要再构造函数里加以判断： 1private LazyMan() &#123;2 // 第二层锁3 synchronized (LazyMan.class) &#123;4 if (LAZY_MAN != null) &#123;5 throw new RuntimeException(\"请不要试图破坏单例模式！\");6 &#125;7 &#125;8 System.out.println(Thread.currentThread().getName() + \" init instance\");9&#125; getInstance上的锁是为了锁住使用getInstance正常获取的线程，而构造方法中的锁是为了锁住通过反射使用构造函数的线程。 由于getInstance上的锁，同一时间只有一个线程可以进入到方法内，即只有一个线程可以使用构造方法，而如果此时有一个线程使用反射方式调用LazyMan构造方法，那么第二层锁就会生效，保证了同一时间只有一个线程能够使用LazyMan类对象的资源，也就防止了反射对于单例模式的破坏。 不过仔细观察上面的代码，不难发现在使用反射之前，就已经通过getInstance方法获取了实例，且LAZY_MAN不是空。那么如果一开始就使用反射呢？ 如果一开始就使用反射，那么LAZY_MAN根本就不会被赋值，它一直未null，所以反射每次调用构造方法都不会抛出异常。 我们需要想办法，不通过LAZY_MAN是否为空来判断实例有没有被创建。 首先想到==增加一个标志位==： 1// 增加标志位，用来判断实例是否已经被创建2private static boolean created = false; 然后根据标志位进行判断： 1private LazyMan() &#123;2 synchronized (LazyMan.class) &#123;3 if (!created) &#123;4 created = true;5 &#125; else &#123;6 throw new RuntimeException(\"请不要试图破坏单例模式！\");7 &#125;8 &#125;9 System.out.println(Thread.currentThread().getName() + \" init instance\");10&#125; 因为无论是getInstance方法，还是通过反射，都需要经过构造函数，所以第一次调用构造函数时，created一定会被置为true，下一次再调用构造函数时，就会因为已经创建过实例而抛出错误。 道高一尺魔高一丈，就算设置了标志位，反射还是获取标志位，通过改变标志位的值再次破坏单例模式 看如下代码： 1// 获取标志位字段对象2Field created = LazyMan.class.getDeclaredField(\"created\");34// 打通权限5created.setAccessible(true);67LazyMan instance2 = declaredConstructor.newInstance();89// 创建实例之后将标志位置为false10created.set(instance2, false); 如此一来，反射再次破坏了单例模式。 那么如何解决这个问题呢？目前是newInstance这个方法创建了实例，不如从这个方法入手。 于是硬着头皮点开newInstance源码，看到了下面这段代码： 1if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)2 throw new IllegalArgumentException(\"Cannot reflectively create enum objects\"); “Cannot reflectively create enum objects”的大概意思是”==无法通过反射来创建枚举对象==”。 看到这里，可谓柳暗花明又一村。 那么赶紧开始下一步行动： 1// 先定义一个枚举类2public enum EnumSingleton &#123;34 INSTANCE;5 6 private EnumSingleton() &#123;7 &#125;89 public EnumSingleton getInstance() &#123;10 return INSTANCE;11 &#125;1213&#125; 下面就要开始测试了： 1Constructor&lt;EnumSingleton&gt; declaredConstructor = EnumSingleton.class.getDeclaredConstructor(null);23declaredConstructor.setAccessible(true);45EnumSingleton enumSingleton = declaredConstructor.newInstance(); 运行之后居然报了错： 1Exception in thread \"main\" java.lang.NoSuchMethodException: com.kasim.designPattern.EnumSingleton.&lt;init&gt;() 说是没有找到构造方法。经过一番查阅资料，发现==枚举类的构造方法只有编译器能调用，无法手动调用==。 于是只能另谋出路，寻找看看有没有其他构造方法。 想到了反编译，把EnumSingleton生成的.class文件反编译成java文件，看看其中到底有没有构造方法。 使用jad反编译，得到java文件中有这样这一部分： 1private EnumSingleton(String s, int i) &#123;2 super(s, i);3&#125; 这明显是个构造方法，它有两个参数，一个是String型，一个是int型，得到这个消息之后立刻回到刚才的测试代码： 1// 改变获取构造器的方式2Constructor&lt;EnumSingleton&gt; declaredConstructor = EnumSingleton.class.getDeclaredConstructor(String.class, int.class);34// 创建实例5declaredConstructor.setAccessible(true);6EnumSingleton enumSingleton = declaredConstructor.newInstance(); 再次运行，得到下面的错误： 1Exception in thread \"main\" java.lang.IllegalArgumentException: Cannot reflectively create enum objects 和newInstance方法源码中的错误相同！！ 所以到这里为止，终于找到了一个防止反射破坏单例模式的方法：==枚举类==。 正义最终还是压制住了邪恶。 最后整理一下代码： 1public enum EnumSingleton &#123;23 // 创建枚举类型的实例4 INSTANCE(LazyMan.getInstance());56 private LazyMan lazyMan;78 // 定义构造方法，在枚举实例上存储单例对象9 private EnumSingleton(LazyMan lazyMan) &#123;10 this.lazyMan = lazyMan;11 &#125;1213 // 获取单例对象14 public static LazyMan getInstance() &#123;15 return INSTANCE.lazyMan;16 &#125;1718&#125; 到这里，终于实现了一个线程安全、漏洞较少的单例模式。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"kasimg.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java","slug":"java","permalink":"kasimg.github.io/tags/java/"}]},{"title":"决策树和随机森林","slug":"决策树","date":"2020-03-03T05:31:04.000Z","updated":"2020-03-19T04:48:03.594Z","comments":true,"path":"2020/03/03/决策树/","link":"","permalink":"kasimg.github.io/2020/03/03/%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"年龄太大？不见 长得不好看？不见 收入太低？不见 … 人们在相亲的时候难免会做出以上的决策，当然，爱美之心人皆有之，而且人人都有追求更好物质生活的精神生活的权利。","text":"年龄太大？不见 长得不好看？不见 收入太低？不见 … 人们在相亲的时候难免会做出以上的决策，当然，爱美之心人皆有之，而且人人都有追求更好物质生活的精神生活的权利。 1. 什么是决策树如果把相亲的决策过程可视化，可以得到下面的图： 图1. 可视化决策过程图中黄色部分表示判断依据，依次按照年龄、长相、收入、是否是公务员4个方面进行决策，最终得出“见”或者“不见”的结论。 此过程长得很像一棵树，所以我们把这种决策方法叫做决策树。 2. 使用决策树2.1 分类问题下面看一个比较具体的问题，下表记录了两个星期内的天气、湿度、风级状况，以及小明是否外出打球： 日期 天气 湿度 风级 是否打球 1 晴 高 弱 否 2 晴 高 强 否 3 阴 高 弱 是 4 雨 高 弱 是 5 雨 正常 弱 是 6 雨 正常 强 否 7 阴 正常 强 是 8 晴 高 弱 否 9 晴 正常 弱 是 10 雨 正常 弱 是 11 晴 正常 强 是 12 阴 高 强 是 13 阴 正常 弱 是 14 雨 高 强 否 现在要求是给出任意的天气、湿度、风级条件，预测出小明是否会出门打球。 2.2 信息熵我们希望画出一课类似图1中的决策树，那么首先需要找到一个特征作为判断依据，这里的特征有三个： 天气 湿度 风级 显然，先选天气作为判断依据，和先选湿度作为判断依据，得到的决策树肯定是不同的。那么既然能得到很多颗决策树，那一颗数比较好呢？ 下面先按照天气划分： 图2. 按照天气划分如何衡量这种划分策略的好坏？ 以所有晴天的数据为例，一共有5个晴天，其中2天小明出去打球，3天没有，那么可以认为在天晴时，小明外出打球的概率为： P(打球|天晴)=\\frac2{2+3}=0.4 \\tag 1考虑下面这个函数： H(p)=-plnp-(1-p)ln(1-p) \\tag 2其中p为事件A发生的概率，这个函数的图像为： 图3. 信息熵图像可以看到，当p为0时，表示事件A不可能发生，此时函数值为0，同样的，当p为1时，表示事件A一定发生，函数值为0。而当p为0.5时，表示事件A发生的概率和不发生的概率相同，函数值达到最大。 这个函数可以用来度量事件的不确定性。当p为0或1时，确定发生或者不发生，确定性最大，所以不确定性最小；反之，p为0.5时不确定性最大。 回到天气划分上，天晴的情况下，小明出门打球的概率为0.4，不确定性比较高，而我们希望不确定性越低越好，从而得到更加精确的决策结果。 式（2）中的H(p)叫做信息熵，用于度量信息的不确定性。 这样一来，我们选择某个特征的标准就是： 特征的熵最小 2.3 特征的信息熵令“小明出门打球”为事件A，天气特征为C，其中： C=\\{C_1,C_2,...,C_n\\} \\tag 3Ci为特征的所有可能取值。 在Ci情况下的信息熵为： H(A,C_i)=-P(A|C_i)*lnP(A|C_i)-\\big(1-P(A|C_i)\\big)ln\\big(1-P(A|C_i)\\big) \\tag 4而这仅仅是特征中一个取值的熵，那么特征C的总信息熵可以定义为： H(A,C)=\\sum_{i=1}^nH(A,C_i)\\cdot w_i \\tag 5其中ωi为特征中各个取值Ci的权重，假设总样本量为n，有j个样本取值为Ci，那么： w_i=\\frac jn这样一来，就可以度量每一个特征的不确定性，选择其中不确定性最小的一个，座位此次划分的标准。 此策略是贪心策略，并不能保证全局最优 2.4 信息增益和信息增益比信息增益定义为： Gain(A, C)=H(A)-H(A,C) \\tag 6表示以C作为判别条件，新的信息熵相较于之前的信息熵下降的幅度。显然，信息增益越大，表示不确定性下降的越多，说明特征选取越好。 现在假设有n个样本，条件C有n中取值，将样本分为n类，每类只有一个样本。那么这种情况下，特征C的熵为0，因为每种取值的熵都为0。这是我们不愿意看到的情况：过拟合 如果以信息增益为判断标准，那么这种可能导致过拟合的特征因为其信息增益最大，所以首当其冲。这并不是我们想看到的。 于是给这些特征一个限制条件，定义信息增益比： GainRatio(A, C)=\\frac {Gain(A,C)}{H(A, C)} \\tag 7将信息增益比作为新的判断条件，需要给出合适的区间（比值太大和太小都不行），这样能排除掉会过拟合的情况，也能保证信息增益较高。 2.5 特征连续的决策边界选取上面的讨论是建立在特征的取值属于一个集合的情况，那么如果特征取值是一个数值（特征连续）该如何？ 看下图： 图4. 决策边界选取有4个样本点，点关于特征C的取值为x1到x4，样本点两两之间的距离为d1，d2，d3。 两个相邻的样本点之间不存在样本点，所以相邻间隔区域的中点b1，b2，b3可以作为候选决策边界。在b1，b2，b3中选择不确定性最小的边界作为最终的决策边界。 这样有一个问题，如果样本数量非常多，那么候选决策边界也会非常多，要是计算每个候选决策边界的熵值，计算成本太高。所以通常的做法是随机选取若干个候选决策边界，找出其中最好的一个。 3. 随机森林为了解决过拟合问题，现采用有放回的采样方式。 假设有样本： X=\\{(X_1,y_1),(X_2,y_2),...,(X_n,y_n)\\}从中有放回地采样m次, 每次取k个，每次的样本为： X_m=\\{(X_{m1},y_{m1}),(X_{m2}y_{m2}),...,(X_{mk},y_{mk})\\}每次的采样结果对应一个决策树DTm，这些决策树组成了一个集合： RF(X)=\\{DT_1,DT_2,...,DT_m\\}这个集合叫做随机森林。 当一个测试点进入随机森林之后，会通过森林中所有的决策树，每棵决策树对应一个分类结果。然后根据少数服从多数的原则，分类结果中频数最高的为最终分类结果。 4. 总结 决策树/随机森林的逻辑比较简单，也许效果不是最好，但是可以作为对数据分布探索的首要尝试算法 没有谈到代码实现部分，以后会补上","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"kasimg.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"对SVM的一些理解","slug":"SVM","date":"2020-02-29T07:04:27.000Z","updated":"2020-03-19T04:44:05.439Z","comments":true,"path":"2020/02/29/SVM/","link":"","permalink":"kasimg.github.io/2020/02/29/SVM/","excerpt":"20世纪90年代曾经制霸机器学习届的SVM，虽然如今风光不再，但是其思想和推导过程仍十分值得学习，所谓温故而知新。","text":"20世纪90年代曾经制霸机器学习届的SVM，虽然如今风光不再，但是其思想和推导过程仍十分值得学习，所谓温故而知新。 1. 更好地分类先看一个简单的分类问题： 图1. 简单的二分类问题如上图所示，-表示负样本，+表示正样本。 有三条分界线a，b，c，直观上来看，将b作为分界线效果更好，因为这样容错率更高。 假设以a为分界线，那么如果负样本观测值因为噪声存在而有所偏差，则很有可能会将这个负样本误判为正样本；同理，以c为分界线也会导致相同的问题。 那么可以这么理解：决策边界的容错率更高，鲁棒性更好，那么我们认为这个边界效果更好。 2. 让街道最宽现在来寻找一个最好的决策边界，体现在图1中就是： 决策边界离样本点尽可能远 公平起见，距离正负样本距离相同 也就是说，要使下图的阴影部分宽度最大： 图2. 阴影部分为了方便起见，后面将这里的阴影部分称作街道。 那么如何让街道最宽呢？ 现有直线L： \\begin{split} &L:\\omega^Tx+b=0 \\\\ &\\omega=(\\omega_1,\\omega_2)^T \\\\ &x=(x_1, x_2)^T \\end{split} \\tag 1平移直线L，记下L最后一次与负样本相交的位置，以及第一次与正样本相交的位置，那么L在这两个对应的直线为M，N： \\begin{split} M&:\\omega^Tx+b=m \\\\[2ex] N&:\\omega^Tx+b=n \\end{split} \\tag 2那么此时MN之间的距离就是街宽。 接着找到直线B，使得B到M和N的距离相等，令B： B:\\omega^Tx+b = 0 \\tag 3那么M，N为： \\begin{split} M&:\\omega^Tx+b=-k \\\\[2ex] N&:\\omega^Tx+b=k \\end{split}具体情形见下图： 图3. 最大街宽此时的决策边界就是直线B。 两边同时乘相同的值，直线解析式不变，对于M和N，两边同时乘1/k，可以得到： \\begin{split} M&:\\frac{\\omega^Tx - b}k = -1 \\\\[2ex] N&:\\frac{\\omega^Tx - b}k = 1 \\\\[2ex] \\end{split} \\tag 4令： (\\omega^T)'=\\frac{\\omega^T}k \\ \\ \\ , \\ \\ \\ b'=\\frac bk有： \\begin{split} M'&:(\\omega^T)'x+b'=-1 \\\\[2ex] N'&:(\\omega^T)'x+b'=1 \\end{split} \\tag 5显然，M和M’以及N和N’是同样的直线，这里为了表示方便，依然用原来的参数，所以： \\begin{split} M&:\\omega^Tx+b=-1 \\\\[2ex] N&:\\omega^Tx+b=1 \\end{split}PS：这里使直线解析式右侧为1/-1有两个原因。第一，如果不加以限制，等比缩放ω和b的话，有无数种可能的解析式，所以这里将其限制住，使得只能得出一种解析式。第二，固定为1/-1是为了方便计算。 落在M和N上的点成为支持向量 获得街道区域之后，不难发现，此时训练集中的样本满足： \\left \\{ \\begin{array}{c} \\omega^Tx+b\\ge1,\\ \\ \\ \\ \\ \\ y=1 \\\\[3ex] \\omega^Tx+b\\le-1,\\ \\ \\ \\ y=-1 \\end{array} \\right. \\tag 6令： y_i= \\left \\{ \\begin{array}{c} 1，x_i为正样本 \\\\[3ex] -1，x_i为负样本 \\end{array} \\right. \\tag 7则样本满足： y_i(\\omega^Tx+b)-1\\ge0 \\tag 83. 计算道路宽度如图： 图4. 计算街道宽度其中A，B分别是直线M，N上的点，过点A做直线N的垂线交N于点P，那么街道宽度AP的长度为： \\begin{split} AP&=\\vec {AB}\\cdot \\frac {\\omega^T}{|\\omega^T|} \\\\ &=(\\vec{OB}-\\vec{OA})\\cdot \\frac {\\omega^T}{|\\omega^T|} \\\\ &=\\vec{OB}\\cdot \\frac {\\omega^T}{|\\omega^T|}-\\vec{OA}\\cdot \\frac {\\omega^T}{|\\omega^T|} \\end{split} \\tag 9因为A，B在M，N上，所以有： \\left \\{ \\begin{array}{c} \\omega^T \\cdot\\vec {OB} + b-1=0 \\\\ -\\omega^T \\cdot\\vec {OA} - b-1=0 \\end{array} \\right. \\tag {10}即： \\left \\{\\begin{array}{c} \\omega^T \\cdot\\vec {OB}=1-b \\\\ \\omega^T \\cdot\\vec {OA}=-b-1 \\end{array}\\right. \\tag {11}所以： \\begin{split} AP&=\\frac1{|\\omega^T|}\\cdot(1-b+b+1) \\\\ &=\\frac2{|\\omega^T|} \\end{split} \\tag {12}至此，得到了街道的宽度，不难发现街道的宽度只和ω有关，和数据集无关。 那么接下来的任务就是让街道尽可能地宽，即求： max(\\frac2{|\\omega^T|})\\Rightarrow min(|\\omega^T|)为了后续计算方便，优化任务变为： \\begin{split} &min(\\frac12|\\omega^T|^2) \\\\[2ex] &s.t.\\ \\ \\ \\ y_i(\\omega^T \\cdot x + b)-1\\ge0 \\end{split} \\tag {13}4. 朗格朗日根据拉格朗日定理，式（13）可转化为求： L=\\frac12|\\omega^T|^2-\\sum_{i=0}^n\\alpha_i\\big(y_i(\\omega^T\\cdot x_i+b)-1\\big) \\tag {14}的极小值。 对ω和b求偏导，求得极值点为： \\left \\{\\begin{array}{c} w^*=\\sum_{i=1}^n\\alpha_iy_ix_i \\\\[2ex] \\sum_{i=1}^n\\alpha_iy_i=0 \\end{array}\\right. \\tag {15}将式（15）代入（14）得： \\begin{split} L&=\\sum_{i=i}^n\\alpha_i-\\frac 12\\sum_{i=1}^n\\alpha_iy_ix_i\\ \\cdot\\sum_{j=1}^n\\alpha_jy_jx_j \\\\ &=\\sum_{i=i}^n\\alpha_i-\\frac 12\\sum_{i=1}^n\\sum_{j=1}^n\\alpha_i\\alpha_jy_iy_jx_ix_j \\end{split} \\tag {16}其中α为超参数，y为样本观测值，y∈{-1, 1}，所以要求L，关键在于xi·xj的值。 5. 核函数上述的一切都发生在二维平面中，而且假设了存在一条直线可以正确地将正负样本分类。那么如果没有这样一条直线能正确分类样本呢？ 假设这样一种情况，现有如下样本： 图5. 二维不可分很明显，没有一条直线能够将正负样本一份为二，那么，如果这些点在三维空间中呢？如下图： 图6. 三维可分将二维空间中的点映射到三维空间中，假设映射结果为上图。其中负样本全部在红色平面靠里（x坐标小于平面x坐标），正样本全部在蓝色平面朝外（x坐标大于平面坐标），且两个平面平行，这样的话，任何一个平行于这两个平面，且在两者之间的平面，都可以作为分隔正负样本的超平面。 将数据从二维映射到三维，成功地用一个平面正确分割。 那么，只需要找到这个映射关系，向更高维映射，我们就能找到一个超平面，二分类样本。 假设有映射关系： \\Phi(x)=x' \\\\ x=(x_1,x_2...,x_n) \\\\ x'=(x_1',x_2',...,x_m')结合式（16），得： L=\\sum_{i=i}^n\\alpha_i-\\frac 12\\sum_{i=1}^n\\sum_{j=1}^n\\alpha_i\\alpha_jy_iy_j\\Phi(x_i)\\Phi(x_j)观察发现，要求得L，并不需要求出映射关系，只需要知道映射之后的两个点的內积即可。 所以大名鼎鼎的核函数就诞生了，核函数就定义为： kernal(x_i, x_j)=\\Phi(x_i)\\Phi(x_j)于是不需要具体映射关系，只需要给出核函数，就可以求得L。 6. 凸优化给定核函数后，可以将原来的问题转化为一个凸优化问题，具体操作过程在此不进行赘述。 7. 总结 本文谈了自己对SVM模型从无到有的过程的理解，略去了凸优化求解的过程。是因为凸优化问题又是一门学问，想搞清楚并非朝夕之事，所以想把精力集中在堆模型本身的理解上。 今后也会刻意简化优化过程，而注重于对模型、算法本身的理解。 加入了用visio画的图，因为发现python不能画出所以自己想要表达的东西","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"kasimg.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"逻辑回归","slug":"logistic-regression","date":"2020-02-26T06:07:59.000Z","updated":"2020-03-19T04:57:36.815Z","comments":true,"path":"2020/02/26/logistic-regression/","link":"","permalink":"kasimg.github.io/2020/02/26/logistic-regression/","excerpt":"逻辑回归常用于分类问题，和线性回归不同的是，前者需要对结果进行分类，而后者是抽象出模型来表征整个数据集。","text":"逻辑回归常用于分类问题，和线性回归不同的是，前者需要对结果进行分类，而后者是抽象出模型来表征整个数据集。 1. 分类问题 图1. 样本点 上图是某班级100个学生两门考试成绩情况，横轴表示第一门考试成绩，纵轴表示第二门，+表示此次考试通过，圆点表示未通过。 现在给定一个学生的成绩，希望预测该学生能否通过此考试。 2. 逻辑回归把通过的样本作为正样本，样本结果为1，未通过的样本视为负样本，样本结果为0。 逻辑回归的任务是训练一个分类器，把学生成绩输入这个分类器，会得到一个0-1之间的数p，p表示这个成绩属于正样本的概率（在这里，就是该同学通过考试的概率）。 不难判断，当p&gt;0.5时，我们认为该学生通过考试，否则认为没有通过。 那么逻辑回归是如何做到这些的呢？ 2.1 sigmoid函数sigmoid函数，表达式如下： S(x) = \\frac 1{1 + e^{-x}} \\tag 1函数图像如下： 图2. sigmoid曲线 当x足够大时，函数值接近1，x足够小时，函数值接近0，而当x=0时，函数值为0.5。 这样的话，无论向函数内输入什么样的值，函数输出总是在0-1之间，符合期望。 之前我有一个疑惑，就是为什么要用sigmoid函数将结果转化为0-1之间的数，现在发现原来是因为正负样本的样本值分别为1和0，如果预测值不转换成0-1之间的数的话，很难计算损失。 2.2 损失函数逻辑回归的损失函数如下： J(\\theta) = \\frac 1m\\sum_{i=1}^m[-y_iln(h_\\theta(x_i)) - (1-y_i)ln(1-h_\\theta(x_i))] \\tag 2向量化之后为： J(\\theta) = -\\frac1m\\big((ln(g(X\\theta))^Ty + (ln(1-g(X\\theta))^T(1-y))\\big) \\tag 3其中： h_\\theta(x) = g(\\theta^Tx) \\tag 4 g(z) = \\frac1{1+e^{-z}} \\tag 5如果采用均方误差，损失函数将不是一个凸函数，所以这里改变了损失函数的形式。 当样本值为1时，损失函数为： J(\\theta) = \\frac 1m\\sum_{i=1}^m[-ln(h_\\theta(x_i))] \\tag 6大约长这个样子 图3. 正样本损失函数 其中横轴为预测值，纵轴为损失。可以看到当预测值x接近0时，损失变得非常大，此时样本值为1，所以这种情况符合预期。 同样的，当样本值为0时，损失图像大概是这样： 图4. 负样本损失函数 当预测值接近1时，损失变得很大，符合预期。 2.3 梯度下降梯度下降之前已经讨论过，这里不做过多赘述，第j个参数的偏导如下： \\frac{\\delta J(\\theta)}{\\delta \\theta_j}=\\frac 1m\\sum_{i=1}^m(h_\\theta(x_i)-y_i)x_{ij} \\tag 7转换为向量形式为： \\frac{\\delta J(\\theta)}{\\delta \\theta_j}=\\frac 1mX^T(g(X\\theta)-y) \\tag 8乍一看这里的（7）式，有些难以理解，那么多ln的式子，求导怎么能得到这个？于是决定 3. 推导偏导数 \\begin{equation}\\begin{split} \\frac{\\delta J(\\theta)}{\\delta \\theta_j}&=-\\frac1m\\sum_{i=1}^m\\big(\\frac{y_i}{h_\\theta(x_i)}\\cdot\\frac\\delta{\\delta\\theta_j}h_\\theta(x_i)-(1-\\frac{1-y_i}{1-h_\\theta(x_i)})\\cdot\\frac\\delta{\\delta\\theta_j}h_\\theta(x_i))\\big) \\\\ &=-\\frac1m\\sum_{i=1}^m\\big(\\frac{y_i}{h_\\theta(x_i)}-\\frac{1-y_i}{1-h_\\theta(x_i)}\\big)\\cdot\\frac\\delta{\\delta\\theta_j}g(\\theta^Tx_i) \\end{split}\\end{equation} \\tag 9而： \\begin{equation}\\begin{split} \\frac\\delta{\\delta\\theta_j}g(\\theta^Tx_i)&=\\frac\\delta{\\delta\\theta_j}\\frac1{1+e^{-\\theta^Tx_i}} \\\\ &=\\frac{e^{-\\theta^Tx_i}}{(1+e^{-\\theta^Tx_i})^2}\\cdot x_{ij} \\end{split}\\end{equation} \\tag 9因为式（5），有： 1-g(\\theta^Tx_i) = \\frac{e^{-\\theta^Tx_i}}{1+e^{-\\theta^Tx_i}} \\tag {10}所以 \\begin{equation}\\begin{split} \\frac\\delta{\\delta\\theta_j}g(\\theta^Tx_i)&=g(\\theta^Tx_i)\\cdot(1-g(\\theta^Tx_i))\\cdot x_{ij}\\\\ &=h_\\theta(x_i)\\cdot(1-h_\\theta(x_i))\\cdot x_{ij} \\end{split}\\end{equation} \\tag{11}那么： \\begin{equation}\\begin{split} \\frac{\\delta J(\\theta)}{\\delta \\theta_j}&=-\\frac1m\\sum_{i=1}^m\\big(\\frac{y_i}{h_\\theta(x_i)}-\\frac{1-y_i}{1-h_\\theta(x_i)}\\big)\\cdot h_\\theta(x_i)\\cdot(1-h_\\theta(x_i))\\cdot x_{ij}\\\\ &=-\\frac1m\\sum_{i=1}^m[y_i-h_\\theta(x_i)]\\cdot x_{ij}\\\\ &=\\frac1m\\sum_{i=1}^m[h_\\theta(x_i)-y_i]\\cdot x_{ij} \\end{split}\\end{equation} \\tag{12}至此，茅塞顿开，浑身舒坦。 4. 结果接下来只要根据梯度下降一步步迭代获取最终模型即可。 下图是分类结果： 图5. 逻辑回归结果 5. 总结 算法实现和画图都是用python做的，这里并没有贴出具体的代码，只谈了对算法的一些认识，因为我觉得代码并不是最重要的，网上一找一大堆，而理解算法本身才是最重要的 markdown的公式编辑真的好用 2020.3.18 补 1. 多分类问题逻辑回归本身是一个二分类问题，如果遇到多分类问题该如何解决？ 首先，逻辑回归可以处理多分类问题，假设有A，B，C三类，有四个分类器L1，L2，L3，L1可以识别出样本属于A或者不属于A，L2可以区分属于B或者不属于B，L3类似。 那么把样本依次经过这三个分类器，就可以得到最终分类。 2.softmax回归上面用多个逻辑回归分类器模拟了多分类的过程，不过多分类问题还可以用一个模型直接解决。 假设有样本： X=(x_1, x_2, ..., x_n) \\\\ Y=(y_1, y_2,...,y_n)其中n为样本数量，m为特征维度。 假设分类的最终结果有k种可能，那么有： \\Theta=(\\theta_1, \\theta_2, ..., \\theta_k)θi（i为1-k的整数）表示每个类别对应的参数。 定义yi被分为第q类的概率为： p(c=q|x_i,\\theta_k)=\\frac{exp(\\theta_q^Tx_i)}{\\sum_{j=1}^kexp(\\theta_j^Tx_i))} \\tag {13}对于给定的yi，令： y_i^k= \\begin {cases} 1,\\ \\ y_i属于第k类 \\\\[2ex] 0,\\ \\ y_i不属于第k类 \\end {cases} \\tag {14}假设yi独立同分布，有关于θ的似然函数： L(\\theta)=\\prod_{i=1}^n (\\prod_{j=1}^k p(c=j|x_i,\\theta_j)^{y_i^j}) \\tag {15}这样的话，后面一个连乘对于每个xi只有一项不为1，所以式（15）也可以直接写成： L(\\theta)=\\prod_{i=1}^np(c=q|x_i,\\theta_q) \\tag {16}因为对于每个yi，其分类已经确定，假设属于第q类，只需要求给定xi后属于第q类的概率即可。 式（16）、式（15）表示从总体样本中取出样本X的概率，这个概率越大，表示从总体样本中抽到这一组数据的概率越大，说明估计的样本分布越接近原始分布，所以需要求L(θ)的最大值。 具体求解过程略…","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"kasimg.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"线性回归与梯度下降","slug":"线性回归","date":"2020-02-14T04:22:41.000Z","updated":"2020-03-19T04:59:10.093Z","comments":true,"path":"2020/02/14/线性回归/","link":"","permalink":"kasimg.github.io/2020/02/14/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","excerpt":"之前由于工作需要重新拾起了机器学习相关的知识，想着一不做二不休，干脆把整个脉络再重新梳理一遍，今天写一点关于梯度下降的理解。 就以线性回归为例来谈谈吧。","text":"之前由于工作需要重新拾起了机器学习相关的知识，想着一不做二不休，干脆把整个脉络再重新梳理一遍，今天写一点关于梯度下降的理解。 就以线性回归为例来谈谈吧。 1. 线性回归1.1 建模假设有学生身高和体重的数据： 学生编号 身高 体重 1 175cm 70kg 2 165cm 50kg 3 185cm 80kg 建立坐标系画出点的分布如下： 图1. 数据点现要预测一个200cm的学生的体重。 我们能大概推算出一个关系：身高越高，体重越重，我们希望用更精确的方式来表达这种关系，这时不难想到中学时学过的解析几何中的一次函数： y=kx+b \\tag 1其中，x表示身高，y表示体重。如果用(1)式表示身高与体重的关系，因为(1)是线性的，所以称这个将模糊的关系精确化的过程叫“线性回归”。 例如将关系总结成如下的直线： 图2. 回归直线 1.2 损失函数现在我们已经得到了一个线性模型，那么如何判断这个模型是不是好呢？ 所谓“好”，就是指和原来的结果接近，最完美的情况下，所有的点都在直线上，当然这并不可能，所以我们要做的事情，就是尽可能地让点接近直线。 假设现在得到的直线是： y=f(x)=\\theta_1 + \\theta_2x \\tag 2于是我们定义第i个点距离直线的距离表示为： D_i=(f(x_i) - y_i)^2 \\tag 3其中xi，yi表示第i个样本的身高值和体重值，Di也可以看做第i个点的样本值与预测值之间的差异程度。 知道了每个点的差异程度，就能知道所有点的差异程度，从而求出平均差异程度： J(\\theta_1,\\theta_2) = \\frac 1{2m}\\sum_{i=1}^m(f(x_i) - y_i)^2 \\tag 4为了方便后续计算，乘上系数1/2。 现在我们的目的很明确，要找到合适的θ，使得差异程度最小。 而这里的差异程度函数，也称作损失函数 经过观察，不难发现这里的损失函数是一个凸函数（具体定义可自行搜索..），这种函数一定有全局最小值，非常适合当做损失函数使用。所以如何构建一个凸函数作为损失函数，是机器学习中的关键。 2. 梯度下降2.1 简单的数学方法求最小值在这个例子里，损失函数是一个二次函数，开口向上，经过简单的数学计算便可以得到最低点。 不过这样计算量非常大，而且仅限于在二元的情况下，如果维度增加，则很难使用此方法解决。 2.2 梯度与偏导梯度，即函数上某一点处使函数值变化最快的方向，转换为代数模式就是导数，导数&gt;0表示增长最快，导数&lt;0表示减少最快。 2.3 关于梯度下降算法的一些思考我看过许多关于梯度下降的文章，大多数都会举“下山”的例子，大概意思是： 人在山顶处，想要下山 沿着负梯度方向，函数值减小最快 选择负梯度方向迈一小步 不停重复上面一个步骤，直到到达山底 “迈出一小步”用公式可以描述为： \\begin{equation}\\begin{split} \\theta_1 : = \\theta_1 - \\alpha\\frac {dJ(\\theta_1, \\theta_2)}{d\\theta_1} \\\\ \\theta_2 : = \\theta_2 - \\alpha\\frac {dJ(\\theta_1, \\theta_2)}{d\\theta_2} \\end{split}\\end{equation} \\tag 5其中α称为学习率，用来控制这里步长的大小。 到这里，我产生了一个疑问，如何解释α与偏导相乘的意义呢？如果因为负梯度方向减少最快，所以沿着此方向迈步，那么“下山”的目标就是： 以最快的速度下山 而如果在一个非直线的函数上，“沿着负梯度方向迈一步”，那么这一步一定会落到函数外侧，那么这一步又有什么意义呢？体现在上面的式子中，-α与偏导相乘表示在负梯度方向跨出一步，而θ只会在横轴或者纵轴方向改变，前后两项方向不一样，如何进行加法运算呢？ 所以我百思不得其解，什么叫“沿着负梯度方向迈一步”，还有，下山的目标真的是“以最快的速度下山吗？” 最快的速度，无非是一步直接跨到山底，但是因为α的存在，真的可能吗？ 所以我想，可能我们不是想“以最快的速度下山”，而是“以最有效的方式下山” 那么怎样才能“最有效”呢？抛开“负梯度方向下函数值减少最快”，去观察凸函数的梯度本身，发现： 越接近函数底部，梯度绝对值越小，变化越平缓，体现在上式中，一开始梯度模比较大，所以α与偏导相乘的值比较大，跨出的步子比较大；而越来越接近底部时，梯度模变小，此时跨出的步子就越小；非常切合实际，越到后面，步子越是要小，否则容易跨过头 如果不小心步子太大，容易直接越过底部，跨到另一边山坡上。而此时导数值符号变化，导致了原来的“向前跨”变成了“向后跨”，这样不至于一直沿着错误的方向跨步。 个人认为，上面的两条原因才是让α与偏导数相乘的原因，而并非因为“负梯度方向下函数值减少最快”。这样的话，α才能真正表示“步长”，而导数，只是从函数中发现的，切合此时情景的参数。 2.4 梯度下降算法经过不断迭代θ值后，使得损失函数越来越小，小到某一范围时，停止算法，变完成了梯度下降算法。 至于何时停止，这篇文章就先不讨论啦.. 3. 回归结果 图3. 回归结果 4. 总结 写出了自己对于梯度下降法的一些理解 忽略了一些细节，后续考虑写一些细节方面的东西 2020.3.16 补 之前直接使用了最小二乘法，而没有深究为何使用它，这里便从极大似然估计角度来谈谈这里使用最小二乘的意义。1. 构建正态分布见下式： y_i = \\theta^Tx_i + \\xi_i \\tag 6其中θTxi为预测值，yi为样本观测值，ξi为误差。 假设样本是独立同分布的，根据中心极限定理，当样本总体数量足够大时，ξ服从正态分布（μ，δ2），总可以调整θ，将常数项对应的θ0减去μ，使得ξ服从（0，δ2）的正态分布。 2. 似然函数此时ξi的概率密度函数为： P(\\xi_i)=\\frac 1{\\sqrt{2\\pi}\\sigma}exp\\left(-\\frac {(\\xi_i)^2}{2\\sigma^2}\\right) \\tag 7将式（6）带入式（7），得： P(y_i|x_i;\\theta) = \\frac 1{\\sqrt{2\\pi}\\sigma}exp\\left(-\\frac {(y_i-\\theta^Tx_i)^2}{2\\sigma^2}\\right) \\tag 8因为样本独立同分布，于是有： \\begin{split} L(\\theta) &= \\prod_{i=1}^mP(y_i|x_i;\\theta) \\\\ &= \\prod_{i=1}^m\\frac 1{\\sqrt{2\\pi}\\sigma}exp\\left(-\\frac {(y_i-\\theta^Tx_i)^2}{2\\sigma^2}\\right) \\end{split} \\tag 9L为似然函数，表示这组样本出现的联合概率。而如今的任务是找到一组θ，使得联合概率最大，这就是所谓的极大似然估计。 3. 最小二乘根据式（9），有： \\begin{split} lnL(\\theta) &= \\sum_{i=1}^mln\\frac 1{\\sqrt{2\\pi}\\sigma}exp\\left(-\\frac {(y_i-\\theta^Tx_i)^2}{2\\sigma^2}\\right) \\\\ &=\\sum_{i=1}^m\\left(ln \\frac1{\\sqrt{2\\pi}\\sigma} -\\frac {(y_i-\\theta^Tx_i)^2}{2\\sigma^2}\\right) \\\\ &=mln \\frac1{\\sqrt{2\\pi}\\sigma}-\\frac1{2\\sigma^2}\\sum_{i=1}^m(y_i-\\theta^Tx_i)^2 \\end{split} \\tag {10}令： J(\\theta) = \\frac 12\\sum_{i=1}^m\\big(h_\\theta(x_i)-y_i\\big) \\tag {11}上式便是目标函数，不难得到： 当J(θ)最小时，似然函数取得最大值 所以最小化J(θ)就成了最终的目标 2020.3.17 补所谓线性回归，指的是对于参数而言是线性的，而非对样本而言。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"kasimg.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"对于PCA算法的个人理解","slug":"PCA","date":"2020-02-11T03:00:19.000Z","updated":"2020-06-30T03:00:52.438Z","comments":true,"path":"2020/02/11/PCA/","link":"","permalink":"kasimg.github.io/2020/02/11/PCA/","excerpt":"由于项目需要，复习了一下读书的时候学过的PCA降维算法，由于太久没用的缘故，忘记了不少。所谓温故而知新，遂以此文章为引，阐述自己对此算法的理解，记录下新的感悟。","text":"由于项目需要，复习了一下读书的时候学过的PCA降维算法，由于太久没用的缘故，忘记了不少。所谓温故而知新，遂以此文章为引，阐述自己对此算法的理解，记录下新的感悟。 1. 降维的意义1.1 遇到问题考虑如下一组数据： 学生编号 性别 头发长度 身高 腿长 体重 衣服尺码 1 男 4cm 175cm 90cm 70kg xl 2 女 40cm 165cm 80cm 50kg m 3 男 3cm 185cm 95cm 80kg xxl 数据一共6个维度，性别、头发长度、身高、腿长、体重、衣服尺码。 经过观察不难看出： 头发的长度和性别息息相关，女生的头发大多比男性的头发长 腿长和身高有关，一般来说，身高越高，腿越长 衣服尺码随身高、体重增加而增大 由于数据各个维度高度相关，导致了有些信息是几乎无用的，比如说衣服尺码，通过身高和体重就能推测出衣服尺码，所以衣服尺码这一信息可有可无；同样的，腿长可以根据身高推测出，这一信息也可以省略。 1.2 数据降维去除数据中的无效维度，只留下主要的维度，或者说主成分。这个过程过程，就可以称之为数据降维。换句话说，我们希望数据各个维度之间是没有关系的，相互独立的。 数据降维的目的就是使数据更加简洁明了。 2. 数学基础略 3. 建模3.1 确定优化目标上面提到，数据降维相当于把一个高维度的向量，映射到一个低维度向量空间中。 假设有二维空间中有5个点： （1，1） （1，3） （2，3） （4，4） （2，4） 表示为矩阵形式： \\begin{bmatrix} 1 & 1 & 2 & 4 & 2 \\\\ 1 & 3 & 3 & 4 & 4 \\\\ \\end{bmatrix} \\tag{1}为了后续表示和计算方便，进行中心化处理，将数据每个维度的的值减去该维度的均值，处理后得到以下结果： \\begin{bmatrix} -1 & -1 & 0 & 2 & 0 \\\\ -2 & 0 & 0 & 1 & 1 \\\\ \\end{bmatrix} \\tag{2}5个点在二维向量空间中表示如下： 图1. 向量空间中的点现在目的是将这些数据映射到一维空间中去，即将图中的这些点映射到一条直线上。 那么问题来了，如何映射才能保证信息最大程度地保留呢？ 假设映射到横轴上，那么横坐标为-1的两个点会合二为一，直接导致了一个点的信息丢失，横坐标为0的点也是如此。 同样的，假设映射到纵轴上，那么也有两个点的信息会丢失。 既然映射之后点的距离太近会导致丢失，那么让他们的距离越远越好。或者说，让他们越分散越好。 3.2 方差在数学中，方差被用来描述数据的离散程度，方差越大，离散程度越高。 所以上面的目标可以转化成，让映射之后的点的方差尽可能地大。 方差的计算公式为： Var(a)=\\frac 1{m-1} \\sum_{r=1}^m{(a_i - \\mu)}^2 \\tag{3}其中a表示数据集，m表示数据个数，ai表示其中某一个数据，μ表示平均值。 由于之前进行过中心化处理，所以可以简化为： Var(a)=\\frac 1{m-1} \\sum_{r=1}^m{a_i}^2 \\tag{4}对于二维向一维映射问题来说，只要找到一个方向，或者找到一条直线，使得映射之后的数据方差最大，那么就得到了最好的映射关系。 3.3 协方差刚才是二维向一维投影，映射之后得到的是一维数据，方差计算较为方便，如果维数更高该怎么办？ 回到一开始的学生信息问题上，我们总是希望数据的各个维度之间没有关系，那么如何衡量数据维度之间的关系呢？ 答案是协方差。假设有数据集X： X= \\begin{bmatrix} a_1 & a_2 & ... & a_m \\\\ b_1 & b_2 & ... & b_m \\\\ \\end{bmatrix} \\tag{5}那么维度a，b的协方差为： Cov(a,b)=\\frac 1{m-1} \\sum_{r=1}^m{(a_i - \\mu_a)}{(b_i - \\mu_b)} \\tag{6}由于进行过中心化，所以有： Cov(a,b)=\\frac 1{m-1} \\sum_{r=1}^m{a_i}{b_i} \\tag{7} 协方差 &gt; 0，表示呈正相关关系 协方差 &lt; 0，表示呈负相关关系 协方差 = 0，表示不相关 3.4 协方差矩阵将协方差写成矩阵形式： \\begin{bmatrix} \\frac 1{m-1} \\sum_{r=1}^m{a_i}^2 & \\frac 1{m-1} \\sum_{r=1}^m{a_ib_i} \\\\ \\frac 1{m-1} \\sum_{r=1}^m{a_ib_i} & \\frac 1{m-1} \\sum_{r=1}^m{b_i}^2 \\\\ \\end{bmatrix} = \\frac 1{m-1}XX^T =C \\tag{8}这里的C就表示X的协方差矩阵，对角线上的元素表示维度的方差，其余元素表示两个维度之间的协方差。 我们希望C经过某种变换之后，只有主对角线上的元素不为0，其他元素都为0，这样的话表示两个维度的数据不相关，能够表示最多的信息量，而这个变化就是要寻找的映射关系。 也就是说，通过变换P，使得C成为一个对角矩阵。 现在假设数据集X的协方差矩阵为C，Y是映射后的数据，P是映射变换矩阵，D是Y的协方差矩阵，那么有： \\begin{equation}\\begin{split} Y&=PX \\\\ D&=\\frac 1{m-1}YY^T \\\\ &=\\frac 1{m-1}(PX)(PX)^T \\\\ &=\\frac 1{m-1}PXX^TP^T \\\\ &=P(\\frac 1{m-1}XX^T)P^T \\\\ &=PCP^T \\end{split}\\end{equation} \\tag{9}所以，此时的目标是： 找到矩阵P，使得D成为对角矩阵 3.6 对角化协方差矩阵伟大的数学先驱们已经为我们总结了许多实对称矩阵的性质，其中有一条： n阶实对称矩阵A必可相似对角化，且相似对角阵上的元素即为矩阵本身特征值。 所以我们一定能找到一个矩阵P，使得式（9）成立 3.7 PCA变换现在，我们得到了映射变换矩阵P，和对角矩阵D（对角线元素自上而下递减），接下来需要选择需要映射到的空间的维度。 假设要映射到K维空间，那么就取P的前k行，此时映射后的数据集Y为： Y_{k×n}=P_{k×m}X_{m×n}至此，完成了PCA算法的所有步骤，成功将数据降维。 4. 总结 文章并未涉及如何选择维度的问题，下次讨论… 2020.3.31 补 之前从数据维度两两不相关角度阐述了对PCA的理解，今天尝试从另外一个角度来解释它。 1. 方差作为目标函数延续之前的3.2，方差越大，说明数据越离散，那么映射效果越好，那么不妨将投影之后的方差作为目标函数。 假设映射关系为P，原数据为x，E为单位矩阵，那么方差为： Var(X) = (XP - E)^T \\cdot (XP - E) \\tag {10}不妨假设已经做过中心化处理，即E=0，再限定u的尺度为1，防止其有无数种取值可能，有： \\begin {split} &Var(X) =P^TX^TXP \\\\ &s.t. \\ \\ \\ \\ P^TP=1 \\end {split} \\tag {11}此时式（11）变成一个带限制条件的求极值问题。 根据拉格朗日定理不难得到，在： X^TXP=\\lambda P \\tag {12}时，目标函数取得极值。入表示拉格朗日参数。 显然XTX为对称矩阵，那么式（12）就可以理解为求方阵XTX的特征值和特征向量，n阶对称矩阵有n个不同的特征值入i，将XTX和对应的特征向量Pi相乘，得到数据在Pi维度的投影，若此时结束，那么就获得了一个一维投影；而如果想要更多维度的数据，那么就要找到更多的Pi，将数据投射到更多的维度。因为对称矩阵的特征向量是两两正交的，所以每个维度之间是不相关的，能够保证反映最大的信息量。 所以，将求得的特征值从大到小排列，选取前k个最大的，就完成了将数据维度降低到k维的效果。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"kasimg.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"react组件中的key属性","slug":"react-key","date":"2020-01-06T04:43:22.000Z","updated":"2020-01-06T05:42:02.666Z","comments":true,"path":"2020/01/06/react-key/","link":"","permalink":"kasimg.github.io/2020/01/06/react-key/","excerpt":"","text":"一直以来，我对react（vue）组件中的key属性并不在意，加上它的原因只不过是不想看到讨厌的warning。 直到昨天，我才发现key的意义所在，以及为什么不推荐用index作为key的值。 1. 遇难题简单介绍一下背景： 一组组件，可以添加或者删除 组件信息从数据库中获取，按时间倒序排列 每个组件中需要和数据库交互，获取额外信息 当时用的key值就是数组中的index，导致组件在增加删除后刷新时出现了问题，过程如下： 原有三个组件，id为：a、b、c，组件中通过数据库获取的数据分别为x、y、z 添加数据d，此时数据库中没有关于d的数据，d组件获取不到数据 重新渲染后，有a、b、c、d四个组件，对应的数据为x、y、z、z 那么问题来了，d应该什么数据也没有，为什么会有数据z呢？ 2. 排查第一时间想到追踪每个组件的数据读取操作，当时数据读取操作写在componentDidMount中，于是在componentDidMount中打印当前组件的id，结果如下： 增加d之前，打印出a、b、c 增加d之后，打印出c 增加d之后，只打印了一次，且打印出了c，说明只有一个c控件被重新渲染。那么为什么只有c被重新渲染？ 结合渲染组件时使用的map操作，突然发现了key这个属性可能是关键所在。 3. 解惑找到了方向，立刻着手分析。 当时的key属性的值是index。增加d之前，a、b、c分别对应0、1、2 增加d之后，由于读取时按时间倒序排列，所以a、b、c、d分别对应1、2、3、0，组件实际的顺序为：d、a、b、c 这么一来，问题就差不多解决了，增加d之后，d、a、b都没有重新渲染，只有c重新渲染了，因为前三个组件的key值和原来一样，所以并没有重新渲染，第四个组件c由于key值为3，原来不存在这样一个key，所以c重新渲染了，并获取了数据z 由于第三个组件没有重新渲染，所以保留着上一次渲染的内容，即z，所以出现了数据z并不是因为数据读取错误，而是因为第三个组件压根没有重新渲染。 问题迎刃而解。 4. 修复鉴于这个问题，把key属性的值改为了数据库记录的唯一标识，问题解决。 5. 总结 这种遇到问题，解决问题，加深对原理的认识的方式很不错，能让人印象深刻 基础还不是很牢，前路漫漫","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"react","slug":"react","permalink":"kasimg.github.io/tags/react/"}]},{"title":"坑坑洼洼的react native之二：node版本","slug":"node-version","date":"2019-12-24T08:20:28.000Z","updated":"2019-12-24T08:26:09.664Z","comments":true,"path":"2019/12/24/node-version/","link":"","permalink":"kasimg.github.io/2019/12/24/node-version/","excerpt":"","text":"今天帮同事搭react native的环境，遇到了之前没有遇到的坑。 1. javajava是先决条件，这点很容易被忽略，因为官方文档中关于java的部分被一笔带过。 2. node版本如果node版本不对的话，最后运行项目时node窗口会闪退，导致最后报错，报错信息也很迷，所以这点也需要注意","categories":[],"tags":[{"name":"react native","slug":"react-native","permalink":"kasimg.github.io/tags/react-native/"}]},{"title":"定时器的运用","slug":"timer","date":"2019-12-11T01:05:34.000Z","updated":"2019-12-11T02:08:16.990Z","comments":true,"path":"2019/12/11/timer/","link":"","permalink":"kasimg.github.io/2019/12/11/timer/","excerpt":"","text":"前一阵子完成了一个有关定时器的任务：在RN中根据时序画图。下面就说说这个还算是有些波折的过程。 1. 背景需求整理如下： 有若干个点存放在sqlite中，点的信息有xy坐标、ts时间戳（ts递增）等 取出这些点，按照时间顺序画出来 2. 第一次尝试刚接到任务的时候第一反应是： 取出所有的点 对于每个点，创建一个setTimeout 取第一个点的ts作为基准时间点 setTimeout的延时长度为对应点ts与基准时间的差值 这样一来，每个点都能在规定的时间被画出来了，看起来没有啥问题，而且实现非常简单。 不过事实并非如此，遇到了如下的问题： 假设有1W个点，那么同时会有几千个定时器存在，占用超多内存，卡爆 由于ts是递增的，到后面定时器的延时时间会非常长，导致报出警告 其实第一个问题就足以让我换一种方法了。 3. 前进一小步既然定时器太多，那么如何减少定时器的数量呢？不难想到用setInterval代替setTimeout，不过问题是，前者只能使用固定的时间间隔，而实际ts间隔是不同的，那么如何解决这个问题？想到了如下折中的办法： 设定间隔时间阈值t(t &gt; 0)，任意两个ts之差的绝对值小于t的点归为一类 同一类的点视作间隔相等，间隔时间为t 每一类对应一个setInterval 第一个setinterval结束后，另一个setinterval开始 这样有两个问题： 1. t过大，大部分点都属于同一类，时间间隔相同，无法复现原有情景 2. t过小，种类过多，导致定时器依然很多 经过多次改变t，找到了比较好的中间值，不过结果仍然差强人意，而且实现较为困难。 4. 停下思考对于有些强迫症的我来说，上面的结果是没有办法接受的，思考了一阵，觉得有两条路： 回归setTimeout，使用两个相邻点的ts之差作为延时量，代替原来的与基础ts的差，且前一个setTimeout完成后才进行下一个setTimeout 想别的办法。 考虑到第一条路实现非常繁琐，需要各种flag判断，再加上经过上面的过程之后，想要找一个精简一点的方法，遂考虑一切推翻重来。 5. 转折正在我思考该如何重来的时候，正在睡午觉的同事的闹钟响了，同事缓缓抬起了头，睁开惺忪的睡眼，站起来去洗手间…等等！闹钟，闹钟，闹钟…!对了，闹钟！ 我可以只创建一个定时器，定时器一直向前走，到了某个时间点唤醒对应的点。 之前我所有的想法都是将点和计时器紧密结合起来，每个点或者几个点对应一个计时器。没有考虑过奖定时器和点分离开来。 6. 大跃进改进后方法如下： 创建一个setinterval，步距设为s 取第一个点的ts为基准ts，取名baseTS 从第一个点开始判断，判断点的ts与baseTS的差值的绝对值是否小于s 如果小于s，那么就画出这个点 否则，将baseTS + s 重复3-5，直到将所有点都画出 这样可以保证每个点都能被画出来，而且步距s的可取范围变得更大。 最终达到了一个令人满意的结果，而且代码量也很少 7. 总结优化无止境，精益求精。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"react native","slug":"react-native","permalink":"kasimg.github.io/tags/react-native/"},{"name":"javaScript","slug":"javaScript","permalink":"kasimg.github.io/tags/javaScript/"}]},{"title":"一些优化","slug":"optimization","date":"2019-12-05T02:51:23.000Z","updated":"2019-12-06T01:29:21.388Z","comments":true,"path":"2019/12/05/optimization/","link":"","permalink":"kasimg.github.io/2019/12/05/optimization/","excerpt":"","text":"sql优化 数据准备优化、RN和android之间通信速度优化 今天review了一下代码，发现以及改正了一些效率低下的地方。 1. RN和android的数据通信因为需求需要，之前写了一个RN和android通信的模块，实现了从android端向RN端传送N条数据，具体实现官网上都有教程，且我并没有遇到什么问题，所以不在此赘述。 当时的实现思路是： 每次传送一条数据 传送N次 传送了1W条数据，每条数据是长度约20的字符串，一共耗时36s，可能由于缺乏对这方面速度概念的理解，当时并没有觉得有什么大问题，直到向BOSS汇报的时候… 于是着手改进。 整理了一下思路，速度主要分为两个部分： 传输操作消耗的基础时间 由于携带数据消耗的额外时间 每次传输的数据量越大，消耗的时间就越长，但是传输次数就减少；而减少每次的传输量，能够加速单次传送，不过传送次数又增加。 想要找到最优解的话，就需要知道每次消耗的时间与数据大小的具体关系。 设计了简单的测试，步骤如下： 一次传送所有数据 结果传送1W条数据只用了1s，可以得到基础结论：单次传输时间成本很高，需要尽量减少传送次数。 为了提高效率，这次就采用了这个较优解，至于最优解，在闲余时间会深入研究。 2. RN和sqlite通信和上面的例子非常相似，只不过这次是关于数据库的操作。 背景是从sqlite中读取1W条数据，之前的步骤是： 读1条数据 读1W次 耗时20s，更改之后的步骤： 一次读所有数据 耗时1s。 3. 总结 RN和android之间的通信是跨语言的，成本比较高，需要减少通信次数 数据库的读写操作成本也很高，需要减少与数据库的交互次数 数据量本身造成的时间成本相较于上面两点，并不高","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"},{"name":"代码review","slug":"正儿八经学技术/代码review","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/%E4%BB%A3%E7%A0%81review/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"kasimg.github.io/tags/react-native/"}]},{"title":"折腾hexo之三：配置与命令","slug":"hexo-config","date":"2019-12-04T04:57:02.000Z","updated":"2019-12-03T05:58:44.618Z","comments":true,"path":"2019/12/04/hexo-config/","link":"","permalink":"kasimg.github.io/2019/12/04/hexo-config/","excerpt":"","text":"这次研究了一下hexo的各种命令和_config.yml配置文件。 1. 命令仅对于常用的命令谈谈自己的理解。 初始化命令 1hexo init 此命令用户在当前目录下生成一个hexo项目 生成部署文件命令 1hexo g 此命令用于在目录下生成public文件夹，而public文件夹中的内容就是之后要部署到服务器上的内容 清除命令 1hexo clean 此命令用于将public文件夹删除，一般在hexo g命令之前使用此命令，防止文件冗余（直接hexo g的话，可能有一些不需要的之前生成的文件残留下来） 开启本地服务命令 1hexo s 部署命令 1hexo d 此命令用于将public文件夹部署到指定服务器上 2. 根目录下的_config.yml配置文件","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"kasimg.github.io/tags/hexo/"}]},{"title":"坑坑洼洼的react native之一：和sqlite不得不说的故事","slug":"sqlite-issues","date":"2019-12-04T04:54:35.000Z","updated":"2019-12-04T11:09:34.275Z","comments":true,"path":"2019/12/04/sqlite-issues/","link":"","permalink":"kasimg.github.io/2019/12/04/sqlite-issues/","excerpt":"","text":"配置问题 多次加载问题 画板优化 因为业务需要，最近开始接触react native，不学不知道，一学才发现，这一定是一条坑洼大道。因为第一步配置就折腾地我死去活来，下面就用文字来发泄我的郁闷之情。 1. react native配置由于用的windows本，所以是按照win+android来配置的，简单说下流程。 nodejs，java环境配置，react-native-cli脚手架安装，不多赘述只需要注意node和npm的权限问题即可 Android环境配置，这里需要认真看官网给出的教程，不然很容易漏装一些乱七八糟的东西，其次注意环境变量的名称和目录即可 创建模拟器，选对安卓版本即可 创建新项目，一行命令搞定。 编译运行项目，一行命令搞定，这里有些点需要注意 要在项目根目录下（有ios和android文件夹）执行命令，不能进入某一个文件夹下 有时编译会不通过，并报“Failed to install the app. Make sure you have the Android development environment set up”的错误，具体原因我不知道，解决方案如下： 把node_modules文件夹删掉，重新npm install，再执行编译命令 干掉整个项目，新建一个 这样一来，react native的基本环境就搭建好了，到这里为止还是比较简单的。 2. react native 下的sqlite插件sqlite对于原生有很好的支持，而RN封装了这些方法，将接口提供给js使用，为了（lao）提升（ban）代码（yao）的复（qiu）用性（de），我毅然决定在RN中写好对数据库的操作，在ios和android两端只要进行配置即可。 谁知道，前路如此坎坷，诸君请听我细细道来。 2.1 配置仅以android端为例，过程参照 https://github.com/andpor/react-native-sqlite-storage 整理如下： npm安装插件，这一步没有什么问题 更改android配置文件settings.gradle。这是卡我卡的最久的一步，按照说明更改配置后，android studio中同步时一直报错，如下： 墙里墙外访问过无数网站，试验过千百种方法……最终发现了问题所在。New File(…)中的路径错了，少了一个/platforms（可是原来错误的路径下也有android文件夹啊！！我特地检查过的！！），下面是正确路径：： 所以问题来了，为啥github和npm上的教程步骤都不对？？？为什么？why？なぜ？ 没人能够回答我… 配置build.gradle文件，这里没有问题 将插件添加到package中，以供js使用。大坑2号出现了！卡我第二久，按照配置配置完之后，美滋滋的开始编译，以为终于雨过天晴，可是迎来的只有冷冷的冰雨，还在脸上胡乱地拍。又报错了….啊啊啊啊！！错误如下： 大致意思是MainApplication模块被创建了两次…于是查看了一下日志，发现启动时有这么一段话： 大致意思是RN会自动加载依赖，可是react-native-sqlite-storage这个依赖被手动加载了，这也和之前的错误对应上了，那么就按照他的解决方案来吧，输入了下面的命令： 1react-native unlink react-native-sqlite-storage 果然还是不行，呵呵，我转过头，外面的天空好蓝，偶尔有几只鸟飞过。 所以，到底是哪里重复创建了？？？ 上了个厕所冷静了一下，重新捋了一遍，发现第三步中，显式地将SQLitePluginPackage加入了packages中，难道这里不需要加进去？管他三七二十一，先试试。 可！以！了！！！ 瞬间浑身舒爽… 等等，那文档里写的啥？？？为啥让我多此一举？？难道是文档没有及时更新吗？？ ……………………. 至此，sqlite插件成功配置完成，额不对，完成了一半，因为还有ios端… 路漫漫，坑洼不断，不过我还是相信总有花明柳暗。 3. 总结总结一下今天的配置过程，很痛苦，不过也学到了很多东西，也培养了屡败屡战的不屈精神，总体来说收获颇丰。 更重要的一点，以后遇到报错一定要截图！！否则后期为了文章里的图还要重现一下bug…","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"react native","slug":"react-native","permalink":"kasimg.github.io/tags/react-native/"},{"name":"sqlite","slug":"sqlite","permalink":"kasimg.github.io/tags/sqlite/"}]},{"title":"折腾hexo之二：更换主题","slug":"beautify","date":"2019-12-03T01:22:11.000Z","updated":"2019-12-03T04:59:21.505Z","comments":true,"path":"2019/12/03/beautify/","link":"","permalink":"kasimg.github.io/2019/12/03/beautify/","excerpt":"作为一个颜控，hexo的默认主题并不能满足我，于是我开启了对博客颜值的追求之旅。","text":"作为一个颜控，hexo的默认主题并不能满足我，于是我开启了对博客颜值的追求之旅。 1. 弱水三千取一瓢打开官网主题页面，200+主题任君挑选。经过一番挑选，最终选择了meterial-x这款主题，无论色调还是风格都是我喜欢的类型，下面是主题截图： (这里不得不提的是，在图片加载过程中遇到了许多问题，会在下一小结详细说明) 还有实例网址： https://xaoxuu.com/ &lt;/br&gt; 2. 插叙：图片加载问题这个问题是在写这篇blog时遇到的，困扰了我一阵子，希望我的解决方案可以帮到以后阅读这篇文章的人。 2.1 原生markdown图片语法问题原来的语法能在文档编辑时正常显示，不过部署后无法显示。于是上网搜集解决方案，先进行了以下操作： 将_config.yml文件中的post_asset_folder配置项设置为true 安装hexo-asset-image插件 1npm install hexo-asset-image --save 此时使用 1npx hexo n post &quot;balabala&quot; 新建文档时，会发现不仅创建了文档本身，还创建了和文档同名的文件夹。将图片放入此文件夹中，对应文档中使用相对路径应该就可以完成图片的显示。 可是并没有。 无奈之下，寻求别的出路。 2.2 官网提供的语法也不行？去hexo官网，发现有专门针对资源的加载语法： 1&#123;% asset_img image.jpg description %&#125; &#x2F;&#x2F; asset_img表示图片资源，image.jpg表示文件夹下图片 的名称，description表示图片描述 立马试了一下，发现还是不行 苦恼之下，打开了chrome开发者工具，试图寻找一丝线索。 结果发现网页中图片的地址解析成了/.com//2019/12/03/文件夹/图片.jpg，问题就出在这里，为啥解析成了这奇怪的东西？难道官网给出的方法也不靠谱，解析出了问题？ 2.3 hexo-asset-image插件bug“只不过是从头再来…”，脑海中想起了刘欢的声音。 于是我把一切推翻重来，按照官网的步骤重新搭建了环境，这次我发现一个奇怪的事情：官网上根本没有提到关于hexo-asset-image插件的事情，而且有这么一段话： 在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 我查看了一下package.json文件，发现hexo的版本是4.0，是3.0之后的版本，所以我用2.0版本的方法试图解决4.0版本的问题，所以出了问题。 所以我这次没有安装hexo-asset-image插件，最后成功在网页上渲染出了图片。 PS: 后来在网上收集资料，确实是hexo-asset-image插件出了问题 最后总结一句话，使用步骤尽量参考官方文档，网上有些博客提供的方法确实不靠谱… &lt;/br&gt; 3. 安装主题安装步骤如下： 下载主题文件，放到项目跟目录下的themes文件夹 在_config.yml文件中找到配置项theme，设置为主题文件夹的名称 重新生成public文件夹： 1npx hexo clean2npx hexo g 这里clean操作可以清除根目录下的public文件夹中的内容，g表示generation，可以生成public文件夹。（public文件夹中的内容就是部署到服务器上的内容） 启动服务： 1npx hexo s 这时就可以看到主题已经应用上了。 &lt;/br&gt; 4. 总结今天更换了喜欢的主题，并且解决了图片无法正常显示的问题，下次准备研究一下_config.yml文件中的各个配置项。","categories":[{"name":"花里胡哨瞎折腾","slug":"花里胡哨瞎折腾","permalink":"kasimg.github.io/categories/%E8%8A%B1%E9%87%8C%E8%83%A1%E5%93%A8%E7%9E%8E%E6%8A%98%E8%85%BE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"kasimg.github.io/tags/hexo/"}]},{"title":"折腾hexo之一：遇见hexo","slug":"遇见hexo","date":"2019-12-02T12:58:37.000Z","updated":"2019-12-03T04:59:22.944Z","comments":true,"path":"2019/12/02/遇见hexo/","link":"","permalink":"kasimg.github.io/2019/12/02/%E9%81%87%E8%A7%81hexo/","excerpt":"一直想搭建一个属于自己的博客，今天终于把这个想法付诸实践，整理一下流程以做纪念，也作为本博客的第一篇文章。","text":"一直想搭建一个属于自己的博客，今天终于把这个想法付诸实践，整理一下流程以做纪念，也作为本博客的第一篇文章。 1. 选型通过网上搜集资料，了解到了3种搭建博客的方式： hexo + github，基于js WordPress，基于php hugo，基于go 考虑到自己对js比较熟悉，再加上能免费把博客挂在github，毫不犹豫选择了hexo。 2. 环境搭建大方向确定之后，便开始着手环境的搭建，流程整理如下： 安装nodejs，由于hexo基于node，所以node是必须的。值得注意的是，window下安装node时可能报2503错误，这是权限导致的问题，解决方法是：使用管理员命令行，将安装文件拖入命令行回车即可。另外，使用npm时如果需要全局安装，那么也需要管理员权限 安装hexo-cli，这是hexo的脚手架工具，用于创建hexo项目，安装命令如下： 1npm install hexo-cli -S 这里我采用了局部安装的方法，因为嫌权限切换太麻烦..而且把hexo-cli包存到package.json文件中，方便之后npm install一条命令安装所有包。如果是全局安装，那么需要管理员权限，命令如下： 1npm install -g hexo-cli 安装hexo，用于对项目进行各种操作 1npm install hexo -S 同样，我选择了局部安装 新建文件夹，用作hexo项目的根目录，在目录下创建hexo环境 1npx hexo init 这里由于我没有加入环境变量，所以加上了npx（具体见官网） 使用以下命令创建本地服务器，预览博客效果 1npx hexo s 通过终端中给出的地址访问博客。至此，环境搭建完成。 创建github仓库，仓库名称必须为：username.github.io，其中username更换成github的id 建立hexo和仓库的连接。打开hexo项目目录下的_config.yml，拉到最低，看见如下代码段： 1# Deployment2## Docs: https://hexo.io/docs/deployment.html3deploy:4 type: git5 repo: 仓库地址6 brach: master 其中有些字段后来加上，type表示部署的方式，这里填上git；repo是repository的缩写，表示仓库，这里填上自己在上一步建立的仓库地址即可；branch默认就是master，这里显式标出，更加清晰 将项目部署到github。一条命令即可： 1npx hexo d 期间会提示输入github账号密码，正常输入即可。至此，部署完成，可以访问username.github.io查看博客。 3. 总结今天简单的搭建了环境，不过仅仅处于“能运行”的状态，距离博客成型还有一段距离。明天试着熟悉hexo的各种操作。","categories":[{"name":"正儿八经学技术","slug":"正儿八经学技术","permalink":"kasimg.github.io/categories/%E6%AD%A3%E5%84%BF%E5%85%AB%E7%BB%8F%E5%AD%A6%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"kasimg.github.io/tags/hexo/"}]}]}